<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Pandas使用 (二)</title>
      <link href="/pandas-learn2/"/>
      <url>/pandas-learn2/</url>
      
        <content type="html"><![CDATA[<p>本文主要以Pandas的案例进行讲解，并介绍在平时使用过程中的一些小技巧。</p><a id="more"></a><h3 id="Axis-轴的概念"><a href="#Axis-轴的概念" class="headerlink" title="Axis-轴的概念"></a>Axis-轴的概念</h3><p>axis：按那个方向检索 0：按逐行索引向下走 1;按逐列 向右走 在drop中使用axis=1实际上是删掉了一列，而在mean中实际上是计算的行平均值，而不是列的平均值。 实际上axis = 1，指的是沿着行求所有列的平均值，代表了横轴，那axis = 0，就是沿着列求所有行的平均值，代表了纵轴。 <img src="/pandas-learn2/axis.png" title="示意图"></p><h3 id="apply使用"><a href="#apply使用" class="headerlink" title="apply使用"></a>apply使用</h3><p>如果我们想创建一个新列，其中包含其他列内容作为输入，那么apply函数会非常有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [45]: df = pd.DataFrame(&#123; &apos;c1&apos;:[ &apos;high&apos; ,&apos;high&apos;, &apos;low&apos;, &apos;low&apos;], &apos;c2&apos;: [0, 23, 17, 4]&#125;)</span><br><span class="line">In [46]: df</span><br><span class="line">Out[46]: </span><br><span class="line">     c1  c2</span><br><span class="line">0  high   0</span><br><span class="line">1  high  23</span><br><span class="line">2   low  17</span><br><span class="line">3   low   4</span><br></pre></td></tr></table></figure><p></p><p>定义一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [47]: def rule(x,y):</span><br><span class="line">    ...:     if x==&apos;high&apos; and y&gt;10:</span><br><span class="line">    ...:         return 1</span><br><span class="line">    ...:     else:</span><br><span class="line">    ...:         return 0</span><br><span class="line">    ...:     </span><br><span class="line">In [48]: df[&apos;new&apos;]=df.apply(lambda x : rule(x[&apos;c1&apos;],x[&apos;c2&apos;]),axis=1)</span><br><span class="line">In [49]: df</span><br><span class="line">Out[49]: </span><br><span class="line">     c1  c2  new</span><br><span class="line">0  high   0    0</span><br><span class="line">1  high  23    1</span><br><span class="line">2   low  17    0</span><br><span class="line">3   low   4    0</span><br></pre></td></tr></table></figure><p></p><h3 id="DataFrame删除行和列"><a href="#DataFrame删除行和列" class="headerlink" title="DataFrame删除行和列"></a>DataFrame删除行和列</h3><p>数据准备如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [1]:</span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line"> </span><br><span class="line">odata = pd.read_csv(&apos;example.csv&apos;)</span><br><span class="line">odata</span><br><span class="line"></span><br><span class="line">Out[1]:</span><br><span class="line">date    spring  summer  autumn  winter</span><br><span class="line">0   2000    12.2338809  16.9073011333   15.6923831333   14.0859622333</span><br><span class="line">1   2001    12.8474805667   16.7504687333   14.5140663667   13.5037456</span><br><span class="line">2   2002    13.558175   17.2033926  15.6999475  13.2336524667</span><br><span class="line">3   2003    12.6547247  16.8949153333   15.6614647  12.8434786667</span><br><span class="line">4   2004    13.2537298  17.0469665667   15.2090537667   14.3647912</span><br><span class="line">5   2005    13.4443049  16.7459822  16.6221879667   11.6108225667</span><br><span class="line">6   2006    13.5056956667   16.8335785667   15.4979282  12.1993436333</span><br><span class="line">7   2007    13.4885262333   16.6677328333   15.8170143667   13.7438216</span><br><span class="line">8   2008    13.1515319  16.4865069333   15.7295728667   12.9323358667</span><br><span class="line">9   2009    13.4577154333   16.6392378333   18.2601799667   12.6531594333</span><br><span class="line">10  2010    13.1945485  16.7286889  15.4263526667   13.8833583</span><br><span class="line">11  2011    14.3477941667   16.6894210333   14.1765804333   12.3665419667</span><br><span class="line">12  2012    13.6050867  17.1305677333   14.7179677667   13.2925524333</span><br><span class="line">13  2013    13.0279078667   17.3861934333   16.2034549667   13.1861213333</span><br><span class="line">14  2014    12.7466816333   16.5442868667   14.7367682  12.8706512467</span><br><span class="line">15  2015    13.465904   16.5061231667   12.4424366333   11.0181384</span><br><span class="line">16  season  spring  summer  autumn  winter</span><br><span class="line">17  slope   0.037969137402  -0.0116468916667    -0.0791384411275    -0.0776527455294</span><br></pre></td></tr></table></figure><p></p><h4 id="删除行"><a href="#删除行" class="headerlink" title="删除行"></a>删除行</h4><p>.drop()方法如果不设置参数<strong>inplace=True</strong>，则只能在生成的新数据块中实现删除效果，而不能删除原有数据块的相应行。如果inplace=True则原有数据块的相应行被删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [4]:</span><br><span class="line">odata.drop(odata.index[[16,17]],inplace=True)</span><br><span class="line">odata</span><br><span class="line"></span><br><span class="line">Out[4]:</span><br><span class="line">date    spring  summer  autumn  winter</span><br><span class="line">0   2000    12.2338809  16.9073011333   15.6923831333   14.0859622333</span><br><span class="line">1   2001    12.8474805667   16.7504687333   14.5140663667   13.5037456</span><br><span class="line">2   2002    13.558175   17.2033926  15.6999475  13.2336524667</span><br><span class="line">3   2003    12.6547247  16.8949153333   15.6614647  12.8434786667</span><br><span class="line">4   2004    13.2537298  17.0469665667   15.2090537667   14.3647912</span><br><span class="line">5   2005    13.4443049  16.7459822  16.6221879667   11.6108225667</span><br><span class="line">6   2006    13.5056956667   16.8335785667   15.4979282  12.1993436333</span><br><span class="line">7   2007    13.4885262333   16.6677328333   15.8170143667   13.7438216</span><br><span class="line">8   2008    13.1515319  16.4865069333   15.7295728667   12.9323358667</span><br><span class="line">9   2009    13.4577154333   16.6392378333   18.2601799667   12.6531594333</span><br><span class="line">10  2010    13.1945485  16.7286889  15.4263526667   13.8833583</span><br><span class="line">11  2011    14.3477941667   16.6894210333   14.1765804333   12.3665419667</span><br><span class="line">12  2012    13.6050867  17.1305677333   14.7179677667   13.2925524333</span><br><span class="line">13  2013    13.0279078667   17.3861934333   16.2034549667   13.1861213333</span><br><span class="line">14  2014    12.7466816333   16.5442868667   14.7367682  12.8706512467</span><br><span class="line">15  2015    13.465904   16.5061231667   12.4424366333   11.0181384</span><br></pre></td></tr></table></figure><p></p><h4 id="删除列："><a href="#删除列：" class="headerlink" title="删除列："></a>删除列：</h4><h4 id="del方法"><a href="#del方法" class="headerlink" title="del方法"></a>del方法</h4><h4 id="pop-方法"><a href="#pop-方法" class="headerlink" title=".pop()方法"></a>.pop()方法</h4><p>.pop方法可以将所选列从原数据块中弹出，原数据块不再保留该列</p><h4 id="drop-方法"><a href="#drop-方法" class="headerlink" title=".drop()方法"></a>.drop()方法</h4><p>drop方法既可以保留原数据块中的所选列，也可以删除，这取决于参数inplace</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">In [8]:</span><br><span class="line">withoutSummer = odata.drop([&apos;summer&apos;],axis=1)</span><br><span class="line">withoutSummer</span><br><span class="line"></span><br><span class="line">Out[8]:</span><br><span class="line">autumn  winter</span><br><span class="line">0   15.6923831333   14.0859622333</span><br><span class="line">1   14.5140663667   13.5037456</span><br><span class="line">2   15.6999475  13.2336524667</span><br><span class="line">3   15.6614647  12.8434786667</span><br><span class="line">4   15.2090537667   14.3647912</span><br><span class="line">5   16.6221879667   11.6108225667</span><br><span class="line">6   15.4979282  12.1993436333</span><br><span class="line">7   15.8170143667   13.7438216</span><br><span class="line">8   15.7295728667   12.9323358667</span><br><span class="line">9   18.2601799667   12.6531594333</span><br><span class="line">10  15.4263526667   13.8833583</span><br><span class="line">11  14.1765804333   12.3665419667</span><br><span class="line">12  14.7179677667   13.2925524333</span><br><span class="line">13  16.2034549667   13.1861213333</span><br><span class="line">14  14.7367682  12.8706512467</span><br><span class="line">15  12.4424366333   11.0181384</span><br><span class="line"></span><br><span class="line">In [9]:</span><br><span class="line">odata</span><br><span class="line"></span><br><span class="line">Out[9]:</span><br><span class="line">summer  autumn  winter</span><br><span class="line">0   16.9073011333   15.6923831333   14.0859622333</span><br><span class="line">1   16.7504687333   14.5140663667   13.5037456</span><br><span class="line">2   17.2033926  15.6999475  13.2336524667</span><br><span class="line">3   16.8949153333   15.6614647  12.8434786667</span><br><span class="line">4   17.0469665667   15.2090537667   14.3647912</span><br><span class="line">5   16.7459822  16.6221879667   11.6108225667</span><br><span class="line">6   16.8335785667   15.4979282  12.1993436333</span><br><span class="line">7   16.6677328333   15.8170143667   13.7438216</span><br><span class="line">8   16.4865069333   15.7295728667   12.9323358667</span><br><span class="line">9   16.6392378333   18.2601799667   12.6531594333</span><br><span class="line">10  16.7286889  15.4263526667   13.8833583</span><br><span class="line">11  16.6894210333   14.1765804333   12.3665419667</span><br><span class="line">12  17.1305677333   14.7179677667   13.2925524333</span><br><span class="line">13  17.3861934333   16.2034549667   13.1861213333</span><br><span class="line">14  16.5442868667   14.7367682  12.8706512467</span><br><span class="line">15  16.5061231667   12.4424366333   11.0181384</span><br></pre></td></tr></table></figure><p></p><p>当inplace=True时.drop()执行内部删除，不返回任何值，原数据发生改变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">In [10]:</span><br><span class="line">withoutWinter = odata.drop([&apos;winter&apos;],axis=1,inplace=True)</span><br><span class="line">type(withoutWinter)</span><br><span class="line"></span><br><span class="line">Out[10]:</span><br><span class="line">NoneType</span><br><span class="line"></span><br><span class="line">In [11]:</span><br><span class="line">odata</span><br><span class="line"></span><br><span class="line">Out[11]:</span><br><span class="line">summer  autumne</span><br><span class="line">0   16.9073011333   15.6923831333</span><br><span class="line">1   16.7504687333   14.5140663667</span><br><span class="line">2   17.2033926  15.6999475</span><br><span class="line">3   16.8949153333   15.6614647</span><br><span class="line">4   17.0469665667   15.2090537667</span><br><span class="line">5   16.7459822  16.6221879667</span><br><span class="line">6   16.8335785667   15.4979282</span><br><span class="line">7   16.6677328333   15.8170143667</span><br><span class="line">8   16.4865069333   15.7295728667</span><br><span class="line">9   16.6392378333   18.2601799667</span><br><span class="line">10  16.7286889  15.4263526667</span><br><span class="line">11  16.6894210333   14.1765804333</span><br><span class="line">12  17.1305677333   14.7179677667</span><br><span class="line">13  17.3861934333   16.2034549667</span><br><span class="line">14  16.5442868667   14.7367682</span><br><span class="line">15  16.5061231667   12.4424366333</span><br></pre></td></tr></table></figure><p></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><hr><ul><li><a href="https://www.jianshu.com/p/67e67c7034f6" target="_blank" rel="noopener">Pandas.DataFrame删除行和列</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas使用 (一)</title>
      <link href="/pandas-learn/"/>
      <url>/pandas-learn/</url>
      
        <content type="html"><![CDATA[<p>Pandas 是非常著名的开源数据处理库，我们可以通过它完成对数据集进行快速读取、转换、过滤、分析等一系列操作。本文会把平时里常用的Pandas操作进行总结。<a id="more"></a></p><h3 id="Group操作"><a href="#Group操作" class="headerlink" title="Group操作"></a>Group操作</h3><p>Groupby 是pandas 中非常重要的一个函数, 主要用于数据聚合和分类计算. 其思想是“split-apply-combine”（拆分 - 应用 - 合并）。 <img src="/pandas-learn/0.png" title="groupby流程"> 只要理解好这个流程思想，进行groupby操作就会相对容易些。</p><p>在接下来的操作中，我们使用Pandas和Numpy类库，首选从网上down一个基础的DataFrame进行相关操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [1]: import pandas as pd</span><br><span class="line">In [2]: import numpy as np</span><br><span class="line">In [3]: url = &apos;https://gist.githubusercontent.com/alexdebrie/b3f40efc3dd7664df5a20f5eee85e854/raw/ee3e6feccba2464cbbc2e185fb17961c53d2a7f5/stocks.csv&apos;</span><br><span class="line">In [4]: df=pd.read_csv(url)</span><br><span class="line">In [5]: df</span><br><span class="line">Out[5]: </span><br><span class="line">          date symbol     open     high      low    close    volume</span><br><span class="line">0   2019-03-01   AMZN  1655.13  1674.26  1651.00  1671.73   4974877</span><br><span class="line">1   2019-03-04   AMZN  1685.00  1709.43  1674.36  1696.17   6167358</span><br><span class="line">2   2019-03-05   AMZN  1702.95  1707.80  1689.01  1692.43   3681522</span><br><span class="line">3   2019-03-06   AMZN  1695.97  1697.75  1668.28  1668.95   3996001</span><br><span class="line">4   2019-03-07   AMZN  1667.37  1669.75  1620.51  1625.95   4957017</span><br><span class="line">5   2019-03-01   AAPL   174.28   175.15   172.89   174.97  25886167</span><br><span class="line">6   2019-03-04   AAPL   175.69   177.75   173.97   175.85  27436203</span><br><span class="line">7   2019-03-05   AAPL   175.94   176.00   174.54   175.53  19737419</span><br><span class="line">8   2019-03-06   AAPL   174.67   175.49   173.94   174.52  20810384</span><br><span class="line">9   2019-03-07   AAPL   173.87   174.44   172.02   172.50  24796374</span><br><span class="line">10  2019-03-01   GOOG  1124.90  1142.97  1124.75  1140.99   1450316</span><br><span class="line">11  2019-03-04   GOOG  1146.99  1158.28  1130.69  1147.80   1446047</span><br><span class="line">12  2019-03-05   GOOG  1150.06  1169.61  1146.19  1162.03   1443174</span><br><span class="line">13  2019-03-06   GOOG  1162.49  1167.57  1155.49  1157.86   1099289</span><br><span class="line">14  2019-03-07   GOOG  1155.72  1156.76  1134.91  1143.30   1166559</span><br></pre></td></tr></table></figure><p>我们接下来以symbol进行分组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [6]:symbols=df.groupby(&apos;symbol&apos;)</span><br><span class="line">In [7]:print(symbols.groups)</span><br><span class="line">&#123;&apos;AAPL&apos;: Int64Index([5, 6, 7, 8, 9], dtype=&apos;int64&apos;), &apos;AMZN&apos;: Int64Index([0, 1, 2, 3, 4], dtype=&apos;int64&apos;), &apos;GOOG&apos;: Int64Index([10, 11, 12, 13, 14], dtype=&apos;int64&apos;)&#125;</span><br></pre></td></tr></table></figure><p>groupby方法是相当灵活的，可以对多个列进行分组。我们可以对symbol和date两列或者更多列进行分组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [21]: df.groupby([&apos;date&apos;,&apos;symbol&apos;]).groups</span><br><span class="line">Out[21]: </span><br><span class="line">&#123;(&apos;2019-03-01&apos;, &apos;AAPL&apos;): Int64Index([5], dtype=&apos;int64&apos;),</span><br><span class="line"> (&apos;2019-03-01&apos;, &apos;AMZN&apos;): Int64Index([0], dtype=&apos;int64&apos;),</span><br><span class="line"> (&apos;2019-03-01&apos;, &apos;GOOG&apos;): Int64Index([10], dtype=&apos;int64&apos;),</span><br><span class="line"> (&apos;2019-03-04&apos;, &apos;AAPL&apos;): Int64Index([6], dtype=&apos;int64&apos;),</span><br><span class="line"> (&apos;2019-03-04&apos;, &apos;AMZN&apos;): Int64Index([1], dtype=&apos;int64&apos;),</span><br><span class="line"> (&apos;2019-03-04&apos;, &apos;GOOG&apos;): Int64Index([11], dtype=&apos;int64&apos;),</span><br><span class="line"> (&apos;2019-03-05&apos;, &apos;AAPL&apos;): Int64Index([7], dtype=&apos;int64&apos;),</span><br><span class="line"> (&apos;2019-03-05&apos;, &apos;AMZN&apos;): Int64Index([2], dtype=&apos;int64&apos;),</span><br><span class="line"> (&apos;2019-03-05&apos;, &apos;GOOG&apos;): Int64Index([12], dtype=&apos;int64&apos;),</span><br><span class="line"> (&apos;2019-03-06&apos;, &apos;AAPL&apos;): Int64Index([8], dtype=&apos;int64&apos;),</span><br><span class="line"> (&apos;2019-03-06&apos;, &apos;AMZN&apos;): Int64Index([3], dtype=&apos;int64&apos;),</span><br><span class="line"> (&apos;2019-03-06&apos;, &apos;GOOG&apos;): Int64Index([13], dtype=&apos;int64&apos;),</span><br><span class="line"> (&apos;2019-03-07&apos;, &apos;AAPL&apos;): Int64Index([9], dtype=&apos;int64&apos;),</span><br><span class="line"> (&apos;2019-03-07&apos;, &apos;AMZN&apos;): Int64Index([4], dtype=&apos;int64&apos;),</span><br><span class="line"> (&apos;2019-03-07&apos;, &apos;GOOG&apos;): Int64Index([14], dtype=&apos;int64&apos;)&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用自定义方法进行groupby操作，在groupby方法中传递自定义方法，该自定义方法需要传递每行的index并返回进行group的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [16]: def increased(idx):</span><br><span class="line">    ...:     return df.loc[idx].close &gt; df.loc[idx].open</span><br><span class="line">    ...: </span><br><span class="line"></span><br><span class="line">In [17]: df.groupby(increased).groups</span><br><span class="line">Out[17]: </span><br><span class="line">&#123;False: Int64Index([2, 3, 4, 7, 8, 9, 13, 14], dtype=&apos;int64&apos;),</span><br><span class="line"> True: Int64Index([0, 1, 5, 6, 10, 11, 12], dtype=&apos;int64&apos;)&#125;</span><br></pre></td></tr></table></figure><p></p><p>对pandas分组的结果进行后续操作，我们对分组结果计算平均值，如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [39]: symbols[&apos;volume&apos;].agg(np.mean)</span><br><span class="line">Out[39]: </span><br><span class="line">symbol</span><br><span class="line">AAPL    23733309.4</span><br><span class="line">AMZN     4755355.0</span><br><span class="line">GOOG     1321077.0</span><br><span class="line">Name: volume, dtype: float64</span><br></pre></td></tr></table></figure><p></p><p>我们也可以同时返回多个需要聚合计算的结果，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [40]: symbols[&apos;volume&apos;].agg([&apos;min&apos;,&apos;max&apos;,&apos;sum&apos;,&apos;mean&apos;])</span><br><span class="line">Out[40]: </span><br><span class="line">             min       max        sum        mean</span><br><span class="line">symbol                                           </span><br><span class="line">AAPL    19737419  27436203  118666547  23733309.4</span><br><span class="line">AMZN     3681522   6167358   23776775   4755355.0</span><br><span class="line">GOOG     1099289   1450316    6605385   1321077.0</span><br></pre></td></tr></table></figure><p></p><p>遍历并选择group</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">In [43]: for symbol,group in symbols:</span><br><span class="line">    ...:     print(symbol)</span><br><span class="line">    ...:     print(group)</span><br><span class="line">    ...:     </span><br><span class="line">AAPL</span><br><span class="line">         date symbol    open    high     low   close    volume</span><br><span class="line">5  2019-03-01   AAPL  174.28  175.15  172.89  174.97  25886167</span><br><span class="line">6  2019-03-04   AAPL  175.69  177.75  173.97  175.85  27436203</span><br><span class="line">7  2019-03-05   AAPL  175.94  176.00  174.54  175.53  19737419</span><br><span class="line">8  2019-03-06   AAPL  174.67  175.49  173.94  174.52  20810384</span><br><span class="line">9  2019-03-07   AAPL  173.87  174.44  172.02  172.50  24796374</span><br><span class="line">AMZN</span><br><span class="line">         date symbol     open     high      low    close   volume</span><br><span class="line">0  2019-03-01   AMZN  1655.13  1674.26  1651.00  1671.73  4974877</span><br><span class="line">1  2019-03-04   AMZN  1685.00  1709.43  1674.36  1696.17  6167358</span><br><span class="line">2  2019-03-05   AMZN  1702.95  1707.80  1689.01  1692.43  3681522</span><br><span class="line">3  2019-03-06   AMZN  1695.97  1697.75  1668.28  1668.95  3996001</span><br><span class="line">4  2019-03-07   AMZN  1667.37  1669.75  1620.51  1625.95  4957017</span><br><span class="line">GOOG</span><br><span class="line">          date symbol     open     high      low    close   volume</span><br><span class="line">10  2019-03-01   GOOG  1124.90  1142.97  1124.75  1140.99  1450316</span><br><span class="line">11  2019-03-04   GOOG  1146.99  1158.28  1130.69  1147.80  1446047</span><br><span class="line">12  2019-03-05   GOOG  1150.06  1169.61  1146.19  1162.03  1443174</span><br><span class="line">13  2019-03-06   GOOG  1162.49  1167.57  1155.49  1157.86  1099289</span><br><span class="line">14  2019-03-07   GOOG  1155.72  1156.76  1134.91  1143.30  1166559</span><br></pre></td></tr></table></figure><p></p><p>获取group全部的keys：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [44]: symbols.groups.keys()</span><br><span class="line">Out[44]: dict_keys([&apos;AAPL&apos;, &apos;AMZN&apos;, &apos;GOOG&apos;])</span><br></pre></td></tr></table></figure><p></p><p>获取group的某一组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [47]: symbols.get_group(&apos;AAPL&apos;)</span><br><span class="line">Out[47]: </span><br><span class="line">         date symbol    open    high     low   close    volume</span><br><span class="line">5  2019-03-01   AAPL  174.28  175.15  172.89  174.97  25886167</span><br><span class="line">6  2019-03-04   AAPL  175.69  177.75  173.97  175.85  27436203</span><br><span class="line">7  2019-03-05   AAPL  175.94  176.00  174.54  175.53  19737419</span><br><span class="line">8  2019-03-06   AAPL  174.67  175.49  173.94  174.52  20810384</span><br><span class="line">9  2019-03-07   AAPL  173.87  174.44  172.02  172.50  24796374</span><br></pre></td></tr></table></figure><p></p><p>count()方法，获取DataFrame每列value的个数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [51]: df.count()</span><br><span class="line">Out[51]: </span><br><span class="line">date      15</span><br><span class="line">symbol    15</span><br><span class="line">open      15</span><br><span class="line">high      15</span><br><span class="line">low       15</span><br><span class="line">close     15</span><br><span class="line">volume    15</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p></p><p>value_counts()方法，该方法返回某一列的不同的个数，bins参数用来指定多少个设置多少个箱：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [61]: df[&apos;volume&apos;].value_counts(bins=4)</span><br><span class="line">Out[61]: </span><br><span class="line">(1072952.085, 7683517.5]    10</span><br><span class="line">(20851974.5, 27436203.0]     3</span><br><span class="line">(14267746.0, 20851974.5]     2</span><br><span class="line">(7683517.5, 14267746.0]      0</span><br><span class="line">Name: volume, dtype: int64</span><br></pre></td></tr></table></figure><p></p><p>counts()和value_counts()方法可以用来快速确定DataFrame的大小。</p><h3 id="Grouper操作"><a href="#Grouper操作" class="headerlink" title="Grouper操作"></a>Grouper操作</h3><p>首先，我们从网上把数据下载下来，后面的操作都是基于这份数据的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [1]: import pandas as pd</span><br><span class="line">In [2]: df = pd.read_excel(&quot;https://github.com/chris1610/pbpython/blob/master/data/sample-salesv3.xlsx?raw=True&quot;)</span><br><span class="line">In [3]: df</span><br></pre></td></tr></table></figure><p></p><img src="/pandas-learn/1.png"><p>下面，我们统计’ext price’这个属性在每个月的累和(sum)值，resample 只有在index为<strong>date</strong>类型的时候才能用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [17]: df.set_index(&apos;date&apos;).resample(&apos;M&apos;)[&apos;ext price&apos;].sum()</span><br><span class="line">Out[17]: </span><br><span class="line">date</span><br><span class="line">2014-01-31    185361.66</span><br><span class="line">2014-02-28    146211.62</span><br><span class="line">2014-03-31    203921.38</span><br><span class="line">2014-04-30    174574.11</span><br><span class="line">2014-05-31    165418.55</span><br><span class="line">2014-06-30    174089.33</span><br><span class="line">2014-07-31    191662.11</span><br><span class="line">2014-08-31    153778.59</span><br><span class="line">2014-09-30    168443.17</span><br><span class="line">2014-10-31    171495.32</span><br><span class="line">2014-11-30    119961.22</span><br><span class="line">2014-12-31    163867.26</span><br><span class="line">Freq: M, Name: ext price, dtype: float64</span><br></pre></td></tr></table></figure><p></p><p>另外关于resample中用到的<strong>M</strong>代表的是聚合时间参数rule，一般是时间参数，比如“M”，“A”，“Q”，“BM”，“BA”，“BQ”和“W”。 <img src="/pandas-learn/2.png" title="时间聚合参数"></p><p>如果我们想知道每个用户每个月的sum值，那么就需要一个groupby了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [20]: df.set_index(&apos;date&apos;).groupby(&apos;name&apos;)[&apos;ext price&apos;].resample(&apos;M&apos;).sum()</span><br><span class="line">Out[20]: </span><br><span class="line">name                             date      </span><br><span class="line">Barton LLC                       2014-01-31     6177.57</span><br><span class="line">                                 2014-02-28    12218.03</span><br><span class="line">                                 2014-03-31     3513.53</span><br><span class="line">                                 2014-04-30    11474.20</span><br><span class="line">                                 2014-05-31    10220.17</span><br><span class="line">                                 2014-06-30    10463.73</span><br><span class="line">                                 2014-07-31     6750.48</span><br><span class="line">                                 2014-08-31    17541.46</span><br><span class="line">                                 2014-09-30    14053.61</span><br><span class="line">                                 2014-10-31     9351.68</span><br><span class="line">                                 2014-11-30     4901.14</span><br><span class="line">                                 2014-12-31     2772.90</span><br><span class="line">Cronin, Oberbrunner and Spencer  2014-01-31     1141.75</span><br><span class="line">                                 2014-02-28    13976.26</span><br><span class="line">                                 2014-03-31    11691.62</span><br><span class="line">                                 2014-04-30     3685.44</span><br><span class="line">                                 2014-05-31     6760.11</span><br><span class="line">                                 2014-06-30     5379.67</span><br><span class="line">                                 2014-07-31     6020.30</span><br><span class="line">                                 2014-08-31     5399.58</span><br><span class="line">                                 2014-09-30    12693.74</span><br><span class="line">                                 2014-10-31     9324.37</span><br><span class="line">                                 2014-11-30     6021.11</span><br><span class="line">                                 2014-12-31     7640.60</span><br></pre></td></tr></table></figure><p></p><p>以上写法不是很直观，可以使用<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Grouper.html" target="_blank" rel="noopener">Grouper</a>写得更加简洁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [22]: df.groupby([&apos;name&apos;,pd.Grouper(key=&apos;date&apos;,freq=&apos;M&apos;)])[&apos;ext price&apos;].sum()</span><br><span class="line">Out[22]: </span><br><span class="line">name                             date      </span><br><span class="line">Barton LLC                       2014-01-31     6177.57</span><br><span class="line">                                 2014-02-28    12218.03</span><br><span class="line">                                 2014-03-31     3513.53</span><br><span class="line">                                 2014-04-30    11474.20</span><br><span class="line">                                 2014-05-31    10220.17</span><br><span class="line">                                 2014-06-30    10463.73</span><br><span class="line">                                 2014-07-31     6750.48</span><br><span class="line">                                 2014-08-31    17541.46</span><br><span class="line">                                 2014-09-30    14053.61</span><br><span class="line">                                 2014-10-31     9351.68</span><br><span class="line">                                 2014-11-30     4901.14</span><br><span class="line">                                 2014-12-31     2772.90</span><br><span class="line">Cronin, Oberbrunner and Spencer  2014-01-31     1141.75</span><br><span class="line">                                 2014-02-28    13976.26</span><br><span class="line">                                 2014-03-31    11691.62</span><br><span class="line">                                 2014-04-30     3685.44</span><br><span class="line">                                 2014-05-31     6760.11</span><br><span class="line">                                 2014-06-30     5379.67</span><br><span class="line">                                 2014-07-31     6020.30</span><br><span class="line">                                 2014-08-31     5399.58</span><br><span class="line">                                 2014-09-30    12693.74</span><br><span class="line">                                 2014-10-31     9324.37</span><br><span class="line">                                 2014-11-30     6021.11</span><br><span class="line">                                 2014-12-31     7640.60</span><br></pre></td></tr></table></figure><p></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><hr><ul><li><a href="https://segmentfault.com/a/1190000012394176" target="_blank" rel="noopener">python处理数据的风骚操作[pandas 之 groupby&amp;agg]</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask_socketio深入探究</title>
      <link href="/flask-socketio/"/>
      <url>/flask-socketio/</url>
      
        <content type="html"><![CDATA[<p>在开发的项目中使用flask作为后台主要技术栈，对于WebSocket来说使用的是flask-socketio，今天我们一起深入探究下，flask-socketio的部署方式、使用过程中的发现的一些有趣的用法。</p><a id="more"></a><p>flask-socketio是flask技术栈中关于WebSocket的解决方案，<a href="https://zh.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSocket</a>是一种在单个TCP连接上进行全双工通信的协议，它帮助客户端与服务器之间建立稳定的长连接会话，传递消息。本次不涉及WebSocket的深入探讨，主要想分享写flask-socketio的实践经验。</p><h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><p>项目初期，flask-socketio是通过gunicorn(单工作者)+nginx+supervisor的方式进行部署，nginx使用ip_hash的方式进行负载均衡。有一次在和同事聊天过程中，讨论到基于ip_hash的方式可能对于在互联网上进行访问的话效果不好，没法做到真正的负载均衡，设想下，一个局域网内有若干台客户端访问服务器，如果基于ip_hash的话，nginx很可能将这些客户端都指向同一台服务器，因为他们的公网ip是一样的。访问过程如下：</p><p>192.168.0.101(用户电脑ip)-&gt;192.168.0.1/116.1.2.3(路由器的局域网ip及路由器得到的电信公网ip)–&gt;119.147.19.234(负载均衡的nginx服务器)–&gt;192.168.126.127(业务应用服务器)。</p><p>为了做到真正的负载均衡，因此将目前项目中nginx的ip_hash方式替换为nginx-sticky-module，sticky就是基于cookie的一种负载均衡解决方案，通过cookie实现客户端与后端服务器的会话保持, 在一定条件下可以保证同一个客户端访问的都是同一个后端服务器。请求来了，服务器发个cookie，并说：下次来带上，直接来找我。该模块支持粘性会话的同时(客户端保持和同一台服务器进行会话访问)可以做到水平扩展。</p><p>理想的flask-socketio架构图：</p><img src="/flask-socketio/1.jpg" title="架构图"><p>它可以保证即使在同一个局域网内的计算机，也可以访问不同的应用服务器，方便以后进行水平扩展。在这里注意的是，在使用gunicorn进行部署的时候，由于gunicorn多工作者(workers)不支持粘性会话，因此运行gunicorn时候确保只有一个工作者启用，启动命令如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn --worker-class eventlet -w 1 module:app</span><br></pre></td></tr></table></figure><p>参考架构图，我们使用的部署方式是nginx作为负载平衡器，使用nginx-sticky(基于cookie)路由，在每一个应用服务器上都运行一个gunicorn进程，每个gunicorn进行使用<strong>单worker</strong>启动。</p><p>在架构图中，可以看到多个应用服务器之间是通过rabbitmq中转的，这是由于每台服务器只拥有客户端连接的一部分，当某一台服务器要进行广播时，有些客户端却连接到了另一台服务器，换句话说服务器只能发送消息给连接到自身服务器的客户端，如果要广播到其他服务器所连接的客户端的话，需要通过rabbitmq或者redis进行中转和协调。</p><p>在使用rabbitmq部署之后，会发现rabbitmq控制面板中会出现应用服务器对应的队列，说明flask-socketio应用服务器之间通过rabbitmq通信来实现跨服务器广播等操作。</p><img src="/flask-socketio/3.png" title="rabbitmq"><p>使用消息队列时，还需要安装其他依赖项：</p><ul><li>对于Redis，必须安装软件包redis（pip install redis）。</li><li>对于RabbitMQ，必须安装软件包kombu（pip install kombu）。</li><li>对于Kombu支持的其他消息队列，请参阅Kombu文档以了解需要哪些依赖关系。</li><li>如果使用eventlet或gevent，那么通常需要修补Python标准库来强制消息队列包使用协程友好的函数和类。</li></ul><h3 id="socketio中namespace和room"><a href="#socketio中namespace和room" class="headerlink" title="socketio中namespace和room"></a>socketio中namespace和room</h3><p>namespace 和room的概念其实用来同一个服务端socket多路复用的。namespace，room和socketio的关系如下。socket会属于某一个room，如果没有指定，那么会有一个default的room。这个room又会属于某个namespace，如果没有指定，那么就是默认的namespace /。</p><p>客户端连接时指定自己属于哪个namespace。服务端看到namespace就会把这个socket加入指定的namespace。socketio广播时以namespace为单位，如果广播给某个room的话需要额外指定room的名字。</p><p>对于namespace和room的概念，如图： <img src="/flask-socketio/2.png" title="namespace和room"></p><h3 id="外部使用"><a href="#外部使用" class="headerlink" title="外部使用"></a>外部使用</h3><p>在项目开发过程中，也对在非flask-socketio项目外发布消息进行了使用，这意味着有的时候我们可以直接emit消息通过一个非socketio服务应用，socketio服务应用需要建立flask实例，并把该实例传入socketio构造函数中，类似这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(&quot;EMDP_WS&quot;)</span><br><span class="line">socketio = SocketIO(app, async_mode=&quot;eventlet&quot;)</span><br></pre></td></tr></table></figure><p>对于在外部使用socketio发布消息，可以通过rabbitmq或者redis进行消息中转，需要指定<strong>message_queue</strong>参数，参考官网如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socketio = SocketIO(message_queue=&apos;redis://&apos;)</span><br><span class="line">socketio.emit(&apos;my event&apos;, &#123;&apos;data&apos;: &apos;foo&apos;&#125;, namespace=&apos;/test&apos;)</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><hr><ul><li><a href="https://blog.csdn.net/yu870646595/article/details/52056340" target="_blank" rel="noopener">Nginx Sticky的使用及踩过的坑（nginx-sticky-module）</a></li><li><a href="https://inkgenius.github.io/flak-SocketIO%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/" target="_blank" rel="noopener">flask-socketio 项目部署</a></li><li><a href="https://blog.csdn.net/lijiecong/article/details/50781417" target="_blank" rel="noopener">socket.io 中namespace 和 room的概念。</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> socketio </tag>
            
            <tag> websocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直播（一）</title>
      <link href="/%E8%A7%86%E9%A2%91/"/>
      <url>/%E8%A7%86%E9%A2%91/</url>
      
        <content type="html"><![CDATA[<p>这几年，随着直播业的发展，直播相关的技术（视频推送、编解码、直播协议等）也越来越热。关于直播业务大体上包括三个主要部分：<strong>设备视频采集和推送</strong>、<strong>流媒体服务器接收和转发</strong>、<strong>客户端播放视频</strong>，每部分涉及的知识也很多，所接触到的协议也很多。</p><a id="more"></a><p>利用春节假期时间研究了些直播、视频推送相关的技术，今天打算总结一下。</p><hr><h3 id="直播流程一：采集"><a href="#直播流程一：采集" class="headerlink" title="直播流程一：采集"></a>直播流程一：采集</h3><p>简单地说，直播业务首先从采集开始，设备上（摄像头、手机等）从系统中（以API方式调用设备接口）获取原始视频数据，视频数据包括<strong>音频数据</strong>和<strong>图像数据</strong>。音频数据通过设备将环境中的模拟信号采集成PCM编码数据，PCM 脉冲编码调制是Pulse Code Modulation的缩写，主要将语音、图像等模拟信号实现数字化的脉冲编码调制技术。然后压缩成对应的压缩格式数据并分发，如MP3、AAC、FLAC等都属于音频压缩格式。</p><p>音频采集阶段，主要技术参数有：</p><ul><li>采样率（samplerate）：采样就是把模拟信号数字化的过程，采样频率越高，记录这一段音频信号所用的数据量就越大，同时音频质量也就越高。在ffmpeg中我们通过-ar参数来设置采样率，采样率的单位是赫兹(Hz)。</li><li>位宽：每一个采样点都需要用一个数值来表示大小，这个数值的数据类型大小可以是：4bit、8bit、16bit、32bit 等等，位数越多，表示得就越精细，声音质量自然就越好，而数据量也会成倍增大。我们在音频采样过程中常用的位宽是 8bit 或者 16bit。</li><li>声道数（channels）：由于音频的采集和播放是可以叠加的，因此，可以同时从多个音频源采集声音，并分别输出到不同的扬声器，故声道数一般表示声音录制时的音源数量或回放时相应的扬声器数量。声道数为 1 和 2 分别称为单声道和双声道，是比较常见的声道参数。ffmpeg中通过-ac channel设置声道数，1：单声道，2：立体声。</li><li>音频帧（frame）：音频数据是流式的，本身没有明确的一帧帧的概念，在实际的应用中，为了音频算法处理/传输的方便，一般约定俗成取2.5ms~60ms 为单位的数据量为一帧音频。这个时间被称之为“采样时间”，其长度没有特别的标准，它是根据编解码器和具体应用的需求来决定的。</li></ul><p>图像采集即采集的图片结果组合成一组连续播放的动画。由于人体眼睛具有视觉暂留现象，也就是说当我们看到一样东西，它就算消失了，我们的视神经对物体的印象不会立即消失，要延续0.1 -0.4秒的时间它才会真正消失，由于上述特性才会有视频存在。图像的采集过程主要由摄像头等设备拍摄成 YUV 颜色编码格式的原始数据，然后经过编码压缩成 H.264 等格式的数据分发出去。常见的视频封装格式有：MP4、3GP、AVI、MKV、WMV、MPG、VOB、FLV、SWF、MOV、RMVB 和 WebM 等。视频压缩算法包括：M-JPEG、Mpeg、H.264、H.265、Wavelet（小波压缩）、JPEG 2000、AVS等。</p><p>图像采集参数，主要有：</p><ul><li>分辨率：随着设备屏幕尺寸的日益增多，视频采集过程中原始视频分辨率起着越来越重要的作用，后续处理环节中使用的所有视频分辨率的定义都以原始视频分辨率为基础。视频采集卡能支持的最大点阵反映了其分辨率的性能。</li><li>采样频率：采样频率反映了采集卡处理图像的速度和能力。在进行高度图像采集时，需要注意采集卡的采样频率是否满足要求。采样率越高，图像质量越高，同时保存这些图像信息的数据量也越大。</li></ul><h3 id="如何采集"><a href="#如何采集" class="headerlink" title="如何采集?"></a>如何采集?</h3><h4 id="1-摄像头采集"><a href="#1-摄像头采集" class="headerlink" title="1. 摄像头采集"></a>1. 摄像头采集</h4><p>比如大华、海康厂商的监控摄像头，这些摄像头配合厂商提供的APP（海康萤石云视频等）进行监控，当然这些摄像头也会提供对应监控RTSP地址。对于手机来说，业界有些技术和SDK支持摄像头的采集。这里以Android为例，罗列可用的技术方案。Android端推流方案大体包括两大类：1. 利用FFmpeg进行直播推流 2. 利用开源项目和SDK</p><ul><li><a href="https://github.com/EasyDarwin/EasyPusher" target="_blank" rel="noopener">EasyPusher RTSP推流SDK</a>：支持RTSP</li><li><a href="https://github.com/EasyDSS/EasyRTMP-Android" target="_blank" rel="noopener">EasyRTMP-Android</a></li><li><a href="https://developer.qiniu.com/pili/sdk/1210/the-android-client-sdk" target="_blank" rel="noopener">七牛播放端SDK</a></li><li><a href="https://www.jianshu.com/p/3c479c0f4876" target="_blank" rel="noopener">MediaCodec做直播推流</a>:需使用LibRtmp将视频数据封成RTMP包</li><li><a href="https://www.jianshu.com/p/3c479c0f4876" target="_blank" rel="noopener">Yasea直播推流</a>:效率高、延迟低</li></ul><h4 id="2-视频文件推流"><a href="#2-视频文件推流" class="headerlink" title="2. 视频文件推流"></a>2. 视频文件推流</h4><p>比如使用ffmpeg软件将一个视频或音频文件以直播流（RTMP、RTSP）的形式推送。</p><hr><h3 id="直播流程二：流媒体服务器接受和转发"><a href="#直播流程二：流媒体服务器接受和转发" class="headerlink" title="直播流程二：流媒体服务器接受和转发"></a>直播流程二：流媒体服务器接受和转发</h3><p>流媒体服务器是流媒体应用的核心系统，主要功能是对流媒体内容采集、存储和转发，并以流式协议（RTSP、RTMP)将视频文件传输到客户端（Web、PC、手机等）。这里不得不提下大名鼎鼎的Adobe公司及其Flash播放器（Flash的装机量以达到99%以上），直播常用到的RTMP协议即为Adobe公司为Flash和服务器间数据传输所开发的协议，如果想使用RTMP做直播的话，前提需要安装并打开Flash。但是关于Flash的诟病（兼容性、后续支持）也是不少的。</p><p>常见的流媒体服务器有：</p><ul><li><a href="https://github.com/Red5/red5-server" target="_blank" rel="noopener">Red5流媒体服务器</a></li><li><a href="https://github.com/EasyDarwin/EasyDarwin" target="_blank" rel="noopener">EasyDarwin服务器</a></li><li><a href="https://github.com/arut/nginx-rtmp-module" target="_blank" rel="noopener">nginx+rtmp_module</a></li><li><a href="https://github.com/rgaufman/live555" target="_blank" rel="noopener">Live555流媒体</a></li><li><a href="https://github.com/EasyDSS/EasyDSS" target="_blank" rel="noopener">EasyDSS流媒体服务器</a></li><li><a href="https://github.com/wowzamediasystems" target="_blank" rel="noopener">Wowza流媒体</a></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><hr><ul><li><a href="https://zhuanlan.zhihu.com/p/22502905" target="_blank" rel="noopener">视频直播技术详解」系列之一：采集</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 直播 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 直播 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法中常用的位操作</title>
      <link href="/BitsOperation/"/>
      <url>/BitsOperation/</url>
      
        <content type="html"><![CDATA[<p>最近一段时间在使用py刷LeetCode的算法题，对于大神写的算法确实感到佩服，另外对于某些基础知识是有必要进行下总结的，比如今天这篇文章的主题位操作，位操作在有些情况下减少不必要的循环，从而带来成倍的性能提升，一起来看下吧。</p><a id="more"></a><p>回顾下基础概念原码、反码、补码，对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式。原码和反码应该接触的比较多，这里重点说下补码，英语也叫two’s complement（对2求补），二进制数在内存中以补码的形式存储。</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>补码的表示方法是: 正数的补码就是其本身 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反 = [00000001]补</span><br><span class="line">[-1] = [10000001]原 = [11111110]反 = [11111111]补</span><br></pre></td></tr></table></figure><p></p><p>对于负数, 补码表示方式也是人脑无法直观看出其数值的。 通常也需要转换成原码在计算其数值.</p><h3 id="取反操作"><a href="#取反操作" class="headerlink" title="取反操作"></a>取反操作</h3><p>按位取反：二进制每一位取反，0变1，1变0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~9的计算步骤：</span><br><span class="line">转二进制：0 1001</span><br><span class="line">计算补码：0 1001</span><br><span class="line">按位取反：1 0110</span><br><span class="line">_____</span><br><span class="line">转为原码：</span><br><span class="line">按位取反：1 1001   </span><br><span class="line">末位加一：1 1010</span><br><span class="line">符号位为1是负数，即-10</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~-9的计算步骤：</span><br><span class="line">转二进制：1 1001</span><br><span class="line">计算补码：1 0111</span><br><span class="line">按位取反：0 1000</span><br><span class="line">_____</span><br><span class="line">转为原码：</span><br><span class="line">正数的补码和原码相同，仍为：0 1000，即8</span><br></pre></td></tr></table></figure><blockquote><p>注意这里面进行任何的操作时，第一步是把原有的数转换成补码，因为计算机内部没有原码，只有补码，为了得到人们的理解，我们在最后转换成人们可以理解的原码。</p></blockquote><h3 id="位操作基本的用法"><a href="#位操作基本的用法" class="headerlink" title="位操作基本的用法"></a>位操作基本的用法</h3><table><thead><tr><th>操作</th><th>英文</th><th>举例</th><th>说明</th></tr></thead><tbody><tr><td>取并集</td><td>Set Union</td><td><code>A&#124;B</code></td><td></td></tr><tr><td>取交集</td><td>Set Intersection</td><td><code>A&amp;B</code></td><td></td></tr><tr><td>按位取反</td><td>Set Negation</td><td><code>ALL_BITS^A or ~A</code></td><td>可参考上面👆的取反操作</td></tr><tr><td>将某位设置为1</td><td>Set Bit</td><td><code>A &#124;=1&lt;&lt;bit</code></td><td>将1左移bit位，然后进行按位或</td></tr><tr><td>将某位设置为0</td><td>Clear Bit</td><td><code>A &amp;=~(1&lt;&lt;bit)</code></td><td>将1左移bit位，全部取反，此时为0111..</td></tr><tr><td>测试某w位的值</td><td>Test Bit</td><td><code>(A &amp;1&lt;&lt;bit)!=0</code></td><td>将A的对应位的值与1相与，如果结果为0，则A的测试位的值为0，否则为1</td></tr><tr><td>删除最后一个1</td><td>Remove Last Bit</td><td><code>A &amp; (A-1)</code></td><td></td></tr><tr><td>获取全部为1的字节</td><td>Get ALL 1 Bits</td><td><code>~0</code></td><td>A 与 A - 1的最后一位必然不同，相与必然为0，结果使最右边一位的1设置为0（这里-1的作用是错位生1）</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><blockquote><p>计算给定数字的二进制1的个数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def count_one(n):</span><br><span class="line">    count = 0</span><br><span class="line">    while(n):</span><br><span class="line">        n = n &amp; (n - 1)</span><br><span class="line">        count += 1</span><br><span class="line"></span><br><span class="line">    return count</span><br></pre></td></tr></table></figure><h4 id="的技巧"><a href="#的技巧" class="headerlink" title="^的技巧"></a>^的技巧</h4><blockquote><p>给出一个数组，这个数组都是由不同的数字组成的，这些数字的取值从 0 到 n，请找出那个丢失的数字。当然，你也可以使用数学方法。 比如: nums = [0, 1, 3] return 2</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def missing_number(nums):</span><br><span class="line">    res = 0</span><br><span class="line">    for i in range(len(nums)):</span><br><span class="line">        res ^= i</span><br><span class="line">        res ^= nums[i]</span><br><span class="line">    res ^= len(nums)</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure><h4 id="的技巧-1"><a href="#的技巧-1" class="headerlink" title="|的技巧"></a>|的技巧</h4><blockquote><p>给定一个数字 N，找出最大的 2 的幂数小于或者等于 N 的值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def largest_power(n):</span><br><span class="line">    n = n | n &gt;&gt; 1</span><br><span class="line">    n = n | n &gt;&gt; 2</span><br><span class="line">    n = n | n &gt;&gt; 4</span><br><span class="line">    n = n | n &gt;&gt; 8</span><br><span class="line">    n = n | n &gt;&gt; 16</span><br><span class="line"></span><br><span class="line">    return n + 1 &gt;&gt; 1</span><br></pre></td></tr></table></figure><p>首先将当前数字的二进制表达式中的最高位的1右边的数字全部置为1，然后再加1，向右移一位。</p><h4 id="amp-的技巧"><a href="#amp-的技巧" class="headerlink" title="&amp;的技巧"></a>&amp;的技巧</h4><blockquote><p>给定一个范围[m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647（0x7FFFFFFF），返回指定范围内所有数字的相与结果。 比如: [5, 7] return 4</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def rangeBitwiseAnd(m,n):</span><br><span class="line">    a=0</span><br><span class="line">    while m!=n:</span><br><span class="line">        m&gt;&gt;1</span><br><span class="line">        n&gt;&gt;1</span><br><span class="line">        a+=1</span><br><span class="line">    return m&lt;&lt;a</span><br></pre></td></tr></table></figure><blockquote><p>写这么一个函数：它可以返回一个无符号整型数的二进制表达式中含有 1 的个数。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def hammingWeight(n):</span><br><span class="line">    count=0</span><br><span class="line">    while(n):</span><br><span class="line">      n&amp;=n-1</span><br><span class="line">      count+=1</span><br><span class="line">    return count</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 理解计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回国后的一些思考</title>
      <link href="/LifeThinking/"/>
      <url>/LifeThinking/</url>
      
        <content type="html"><![CDATA[<p>2017年3月份回国，到现在已经半年多了，这篇文章的没有任何写作初衷，完全是出于一种莫名的写作冲动，于是重新在换完SSD的MBP上安装NEXT环境，打算怒写一篇所谓的随笔。。。</p><a id="more"></a><p>继续过着一人漂泊在外的日子，在北京我认为对于我来说这里就是个工作的地方，每周六日会回到石家庄享受家人的陪伴，还好和公司同事的关系都不错，毕竟都是攻城狮，想法都很单纯，人都很实在，时不时的会和公司同事搞个饭局，友谊增进不少。目前工作上的项目要进入“真正”的适用阶段了，希望早日把我们的系统早日步入正轨，平时工作上的内容对我来说到没有特别大的挑战，因此基本上可以比较出色的完成，但是我应该是个想法比较多、占有欲比较强的人，找些有趣、有意义的东西去Learn才能满足自己，目前在在入门学习当今火热的人工智能-机器学习部分，大学里学过的高数、概率等学科只有用对了地方才能领会到数学的魅力。。。</p><p>要学的东西真的还有很多，还好我的态度还不错（自我安慰一发），慢慢的要考虑的事情还有许多，结婚、家庭、未来职业发展等，都说简单的生活是最好的，可是如何把不简单的生活活得简单呢？在国外的日子是用来怀念的，但不是去羡慕的，怀念用法语交谈的日子，希望明年见到Les Charles时我的法语还不错，活在当下是我的一个特性，以前留学工作的日子还是摆在我家的相框里吧。</p><p>最近半年来，从入职Nuctech到现在，工作上还算说得过去，和大家相处融洽，工作上稳步提升，希望我可以一直保持一个学习的心，充满新鲜感的对待工作，我觉得这点很重要。对了，这半年来我坚持游泳，平均一周4次左右吧，自由泳由一开始最多游1圈，到现在一口气1200米+（小泳池20圈），另外也擅长蝶泳，可谓擅长四种泳姿，算是自己在工作之外的一个小突破吧，其实这也是兴趣演变的一个成果。寻找下一个突破吧，最好是技术上的吧。</p><p>我很幸运，因为对于爸妈、老婆，他们做的或是忍受的比我要多很多，我很享受也向往每个六日与他们团聚的日子。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库连接池</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>最近在开发项目的时候遇到由于连接池超时导致前端数据不显示的问题，经过发现是因为，在建立连接的过程中没有及时释放资源，导致连接池没有可用连接，从而不能相应前端请求造成超时，今天一起来看下关于Sql Server中连接池的使用。</p><a id="more"></a><h3 id="什么是连接池"><a href="#什么是连接池" class="headerlink" title="什么是连接池?"></a>什么是连接池?</h3><p>建立一个数据库连接是一件非常耗时的过程，之所以是这样，是因为连接到数据库服务器需要经历几个漫长的过程： 建立物理通道（例如套接字或命名管道），与服务器进行初次握手，分析连接字符串信息，由服务器对连接进行身份验证，运行检查以便在当前事务中登记等等。如果每次建立都是很耗时耗力的话，是不是可以重复利用已有的连接呢？</p><p>因此<strong>连接池</strong>便出现了，连接池实际上是一个容器，在容器内存放了一定数量与数据库服务器的物理连接。因此，当我们需要连接数据库服务的时候，只需要从容器内取一条空闲的连接，而不是新建一个连接。将先前的连接保存下来，当下一次需要打开连接的时候就将先前的Connection交个下个链接。这样会大大减少连接数据库的开销，从而提高程序性能。</p><h3 id="数据库Connection-Pool连接池运行原理"><a href="#数据库Connection-Pool连接池运行原理" class="headerlink" title="数据库Connection Pool连接池运行原理"></a>数据库Connection Pool连接池运行原理</h3><p>当一个程序执行Connection.open()时候，ADO.net就需要判断，此连接是否支持Connection Pool (Pooling 默认为True)。</p><ul><li>若为False, ADO.net就与数据库之间创建一个连接，然后返回给程序。</li><li>若为True，ADO.net就会根据ConnectString创建一个Connection Pool，然后向Connection Pool中填充Connection。填充多少个Connection由Min Pool Size (默认为0)属性来决定。例如如果指定为5，则ADO.net会一次与SQL数据库之间打开5个连接，然后将4个Connection，保存在 Connection Pool中，1个Connection返回给程序。</li></ul><p><a href="https://postimg.org/image/uwig70spf/" target="_blank" rel="noopener"><img src="https://s13.postimg.org/87t97gbbr/connection_pool1.png" alt="连接池1"></a></p><p>当程序执行到Connection.close() 的时候。如果Pooling 为True，ADO.net 就把当前的Connection放到Connection Pool并且保持与数据库之间的连接。</p><p>下一次Connection.Open()的时候，ADO.NET就会判断ConnectionString与之前保存在连接池中的Connection的ConnectionString是否有一致。若一致进入同一个连接池，否则创建新的连接池。</p><p>ADO.NET需要判断当前的Connection Pool中是否有可以使用的Connection(没有被其他程序所占用)，如果没有的话，ADO.NET就需要判ConnectionString设置的Max Pool Size （默认为100）</p><ul><li>如果Connection Pool中的所有Connection没有达到Max Pool Size，ADO.net则会再次连接数据库，创建一个连接，然后将Connection返回给程序。</li><li>如果已经达到了 MaxPoolSize，ADO.NET就不会再次创建任何新的连接，新的连接请求将放置到连接队列中。当有连接释放给连接池时，连接池将新释放的连接分配给在队列中排队的连接请求。</li></ul><p><a href="https://postimg.org/image/h40b6wlvt/" target="_blank" rel="noopener"><img src="https://s12.postimg.org/vn7g8bf0t/connection_pool2.png" alt="连接池2"></a></p><h3 id="使用连接池"><a href="#使用连接池" class="headerlink" title="使用连接池"></a>使用连接池</h3><p>连接池的行为可以通过连接字符串来控制，主要包括四个重要的属性：</p><ul><li>Connection Timeout：连接请求等待超时时间。默认为15秒，单位为秒。</li><li>Max Pool Size: 连接池中最大连接数。默认为100。</li><li>Min Pool Size: 连接池中最小连接数。默认为0。</li><li>Pooling: 是否启用连接池。ADO.NET默认是启用连接池的，因此，你需要手动设置Pooling=false来禁用连接池。</li></ul><p>当用户打开一个连接而没有正确或者及时的关闭时，经常会引发”连接泄漏”的问题，泄露的连接会一直保持打开的状态，是的后续连接请求处于等待状态。因此需要注意及时的释放使用完的连接。</p><p>下例中，由于没有及时释放连接资源，导致程序跑出异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Data.SqlClient;</span><br><span class="line"></span><br><span class="line">namespace SqlConnectionTester</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        private static SqlConnection conn;</span><br><span class="line"></span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            SqlConnectionStringBuilder connStr = new SqlConnectionStringBuilder();</span><br><span class="line">            connStr.DataSource = @&quot;.&quot;;</span><br><span class="line">            connStr.InitialCatalog = &quot;Nuctech.NIS.OnlineTax&quot;;</span><br><span class="line">            connStr.IntegratedSecurity = false;</span><br><span class="line">            connStr.UserID = &quot;sa&quot;;</span><br><span class="line">            connStr.Password = &quot;123456&quot;;</span><br><span class="line"></span><br><span class="line">            connStr.MaxPoolSize = 5;//设置最大连接池为5</span><br><span class="line">            connStr.ConnectTimeout = 2;//设置超时时间为1秒</span><br><span class="line">            </span><br><span class="line">            for (int i = 1; i &lt;= 10; ++i)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                var conn = new SqlConnection(connStr.ConnectionString);</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    conn.Open();</span><br><span class="line">                    Console.WriteLine(&quot;Connection&#123;0&#125; is linked&quot;, i);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Exception ex)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;\n异常信息:\n&#123;0&#125;&quot;, ex.Message);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://postimg.org/image/se4nge4ax/" target="_blank" rel="noopener"><img src="https://s12.postimg.org/pk1i2y24t/connection_error.png" alt="未及时释放连接导致连接超时"></a></p><p>不是显式关闭的连接可能不会添加或返回到池中。因此要使用<strong>Using</strong>关键字将连接资源包起来，或者当连接使用完之后，使用Connection对象的<strong>Close()</strong>或<strong>Dispose()</strong>方法，垃圾回收器(GC)才关闭和释放连接，避免上述问题。</p><h3 id="查看数据库连接数"><a href="#查看数据库连接数" class="headerlink" title="查看数据库连接数"></a>查看数据库连接数</h3><ul><li><p>监视连接状态，不指定用户名则返回所有的Sql Server数据库连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sp_who sa</span><br></pre></td></tr></table></figure></li><li><p>通过系统表来查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from sysprocesses where dbid= db_id(数据库ID)</span><br></pre></td></tr></table></figure></li><li><p>查看已经使用的连接数个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from sys.dm_exec_connections</span><br></pre></td></tr></table></figure></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><hr><ul><li><a href="http://www.cnblogs.com/liuhaorain/archive/2012/02/19/2353110.html" target="_blank" rel="noopener">ADO.NET入门教程（五） 细说数据库连接池</a></li><li><a href="http://www.cnblogs.com/zhangji/p/5476734.html" target="_blank" rel="noopener">.NET 数据库连接池超时问题</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库连接池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET Core依赖注入</title>
      <link href="/net%20core%20di/"/>
      <url>/net%20core%20di/</url>
      
        <content type="html"><![CDATA[<p>依赖注入在实际项目中用处很广，用的不好会导致莫名其妙的结果，本人也在实践中经历了它所带来的坑，因此有必要需要搞清楚.NET Core中的依赖注入实现原理。</p><a id="more"></a><p>IoC主要体现了这样一种设计思想：通过将一组通用流程的控制从应用转移到框架之中以实现对流程的复用，同时采用“好莱坞原则”是应用程序以被动的方式实现对流程的定制。我们可以采用若干设计模式以不同的方式实现IoC，比如我们在上面介绍的模板方法、工厂方法和抽象工厂，接下来我们介绍一种更为有价值的IoC模式，即依赖注入（DI：Dependency Injection，以下简称DI）。</p><h3 id="什么是依赖注入"><a href="#什么是依赖注入" class="headerlink" title="什么是依赖注入"></a>什么是依赖注入</h3><p>依赖注入是为了达到解耦对象和其依赖的一项技术。一个类为了完成自身某些操作所需的对象是通过某种方式提供的，而不是使用静态引用或者直接实例化。通常情况下，类通过构造器来声明其依赖，遵循显式依赖原则。这种方式称作构造器注入。</p><p>当以DI思想来设计类时，这些类更加松耦合，因为他们不直接硬编码的依赖其合作者。这遵循了依赖倒置原则，即高层模块不应依赖底层模块，两者都应依赖抽象。类在构建时所需是抽象（如接口interface），而不是具体的实现。把依赖抽离成接口，把这些接口的实现作为参数也是策略设计模式的例子。在实际项目中，高层类库需要使用底层基础类库的功能，但是过多的在高层类库通过实例化的方法引入底层方法会使得项目的耦合性过高，不利于后期的开发和测试，我们希望每次一层的代码更加专注和独立。</p><p>把这几个问题搞明白了，我想依赖注入和控制反转（DI/IOC）也就明白了。</p><ul><li>参与者都有谁?</li></ul><p>一般有三方参与者，一个是某个对象；一个是IoC/DI的容器；另一个是某个对象的外部资源。又要名词解释一下，某个对象指的就是任意的、普通的Java对象; IoC/DI的容器简单点说就是指用来实现IoC/DI功能的一个框架程序；对象的外部资源指的就是对象需要的，但是是从对象外部获取的，都统称资源，比如：对象需要的其它对象、或者是对象需要的文件资源等等。</p><ul><li>谁依赖于谁?</li></ul><p>当然是某个对象依赖于IoC/DI的容器。</p><ul><li>谁注入谁？</li></ul><p>IOC/DI容器注入某个需要依赖的对象。</p><ul><li>到底注入什么？</li></ul><p>就是注入某个对象所需要的外部资源。</p><ul><li>谁控制谁？</li></ul><p>当然是IoC/DI的容器来控制对象了。</p><ul><li>控制什么？</li></ul><p>主要是控制对象实例的创建。</p><ul><li>为何叫反转？</li></ul><p>反转是相对于正向而言的，那么什么算是正向的呢？考虑一下常规情况下的应用程序，如果要在A里面使用C，你会怎么做呢？当然是直接去创建C的对象，也就是说，是在A类中主动去获取所需要的外部资源C，这种情况被称为正向的。那么什么是反向呢？就是A类不再主动去获取C，而是被动等待，等待IoC/DI的容器获取一个C的实例，然后反向的注入到A类中。</p><ul><li>依赖注入和控制反转是同一个概念吗？</li></ul><p>根据上面的讲述，应该能看出来，依赖注入和控制反转是对同一件事情的不同描述，从某个方面讲，就是它们描述的角度不同。依赖注入是从应用程序的角度在描述，可以把依赖注入描述完整点：应用程序依赖容器创建并注入它所需要的外部资源；而控制反转是从容器的角度在描述，描述完整点：容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。</p><h3 id="ASP-NET-Core中的依赖注入"><a href="#ASP-NET-Core中的依赖注入" class="headerlink" title="ASP.NET Core中的依赖注入"></a>ASP.NET Core中的依赖注入</h3><p>ASP.NET Core包含一个简单的内置容器（由IServiceProvider接口表示），默认情况下支持构造函数注入，ASP.NET通过DI提供某些服务。可以在Startup类中的ConfigureServices方法中配置内需要注入的服务。</p><p>使用.NET Core内置的服务。</p><table><thead><tr><th>服务类</th><th style="text-align:center">生命周期</th></tr></thead><tbody><tr><td>Microsoft.AspNetCore.Hosting.IHostingEnvironment</td><td style="text-align:center">Singleton</td></tr><tr><td>Microsoft.Extensions.Logging.ILoggerFactory</td><td style="text-align:center">Singleton</td></tr><tr><td>Microsoft.Extensions.Logging.ILogger<t></t></td><td style="text-align:center">Singleton</td></tr><tr><td>Microsoft.AspNetCore.Hosting.Builder.IApplicationBuilderFactory</td><td style="text-align:center">Transient</td></tr><tr><td>Microsoft.AspNetCore.Http.IHttpContextFactory</td><td style="text-align:center">Transient</td></tr><tr><td>Microsoft.Extensions.Options.IOptions&lt;T&gt;</td><td style="text-align:center">Singleton</td></tr><tr><td>System.Diagnostics.DiagnosticSource</td><td style="text-align:center">Singleton</td></tr><tr><td>System.Diagnostics.DiagnosticListener</td><td style="text-align:center">Singleton</td></tr><tr><td>Microsoft.AspNetCore.Hosting.IStartupFilter</td><td style="text-align:center">Transient</td></tr><tr><td>Microsoft.Extensions.ObjectPool.ObjectPoolProvider</td><td style="text-align:center">Singleton</td></tr><tr><td>Microsoft.Extensions.Options.IConfigureOptions<t></t></td><td style="text-align:center">Transient</td></tr><tr><td>Microsoft.AspNetCore.Hosting.Server.IServer</td><td style="text-align:center">Singleton</td></tr><tr><td>Microsoft.AspNetCore.Hosting.IStartup</td><td style="text-align:center">Singleton</td></tr><tr><td>Microsoft.AspNetCore.Hosting.IApplicationLifetime</td><td style="text-align:center">Singleton</td></tr></tbody></table><p>在.net core源码的ServiceCollectionExtensions的实现中，有三个注册的方法AddScoped、AddSingleton、AddTransient。这其中的三个选项（Singleton、Scoped和Transient）体现三种对服务对象生命周期的控制形式。</p><p><strong>Singleton</strong>：ServiceProvider创建的服务实例保存在作为根节点的ServiceProvider上，所有具有同一根节点的所有ServiceProvider提供的服务实例均是同一个对象。适合于单例模式。</p><p><strong>Scoped</strong>：ServiceProvider创建的服务实例由自己保存，所以同一个ServiceProvider对象提供的服务实例均是同一个对象。 可以简单的认为是每请求（Request）一个实例，在一个请求中的对象实例都是同一个。</p><p><strong>Transient</strong>：针对每一次服务提供请求，ServiceProvider总是创建一个新的服务实例。 每次访问时被创建，适合轻量级的，无状态的服务。</p><blockquote><p>Entity Framework上下文需要使用Scoped生命周期注入到服务容器内，同样使用Entity Framework的Repository需要同样使用Scoped生命周期注入到服务容器。</p></blockquote><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> #region 依赖注入</span><br><span class="line">// 创建数据库上下文</span><br><span class="line">var contextOptions = new DbContextOptionsBuilder&lt;NuctechDbContext&gt;().UseSqlServer(Configuration.GetConnectionString(&quot;Nuctech.OnlineTax.DbConnStr&quot;)).Options;</span><br><span class="line"></span><br><span class="line">#region 仓储部分 DbContextOptions作为单例进行注册，EFCoreContext和Repository作为Scoped进行注册，每请求一个新实例</span><br><span class="line"></span><br><span class="line">services.AddSingleton(contextOptions).AddScoped&lt;NuctechDbContext&gt;();</span><br><span class="line">services.AddScoped&lt;IRepositoryContext, EntityFrameworkRepositoryContext&gt;();</span><br><span class="line">services.AddScoped&lt;IEntityFrameworkRepositoryContext, EntityFrameworkRepositoryContext&gt;();</span><br><span class="line">services.AddScoped&lt;IPassengerRepository, PassengerRepo&gt;();</span><br><span class="line">services.AddScoped&lt;IContactRepository, ContactRepository&gt;();</span><br><span class="line">services.AddScoped&lt;IDeclarationRepository, DeclarationRepository&gt;();</span><br><span class="line">services.AddScoped&lt;IDeclarationItemRepository, DeclarationItemRepository&gt;();</span><br><span class="line">services.AddScoped&lt;ICategoryRepository, CategoryRepository&gt;();</span><br><span class="line">services.AddScoped&lt;IAnnouncementRepository, AnnouncementRepository&gt;();</span><br><span class="line">#endregion</span><br><span class="line"></span><br><span class="line">#region 服务部分 每次访问都创建新的实例</span><br><span class="line"></span><br><span class="line">services.AddTransient&lt;IResponseService, ResponseService&gt;();</span><br><span class="line">services.AddTransient&lt;IContactService, ContactService&gt;();</span><br><span class="line">services.AddTransient&lt;IPassengerService, PassengerService&gt;();</span><br><span class="line">services.AddTransient&lt;IDeclarationService, DeclarationService&gt;();</span><br><span class="line">services.AddTransient&lt;ICategoryService, CategorySevice&gt;();</span><br><span class="line">services.AddTransient&lt;IAnnouncementService, AnnoucementService&gt;();</span><br><span class="line">#endregion</span><br><span class="line"></span><br><span class="line">#endregion</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> .NET开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NET Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Async 和 Await总结</title>
      <link href="/async/"/>
      <url>/async/</url>
      
        <content type="html"><![CDATA[<p>一开始自己翻译了一篇外国技术大牛关于async、await的博文，感觉没法使用特别自然的语言进行描述，索性就把翻译的文章一股脑清空了，然后上网看了些其他博友的讲解，有的讲 的过于深刻不便于理解，因此我以自己关于这部分曾经思考过的问题与大家分享下。</p><a id="more"></a><h3 id="问题一：异步方法一定需要等待吗？"><a href="#问题一：异步方法一定需要等待吗？" class="headerlink" title="问题一：异步方法一定需要等待吗？"></a>问题一：异步方法一定需要等待吗？</h3><p>首先要明确谁等，怎么等，请先看一段常见代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> namespace AsyncAwaitTest</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;-------主线程启动-------&quot;);</span><br><span class="line">            Task&lt;int&gt; task = GetLengthAsync();</span><br><span class="line">            Console.WriteLine(&quot;Main方法做其他事情&quot;);</span><br><span class="line">            Console.WriteLine(&quot;Task返回的值&quot; + task.Result);</span><br><span class="line">            Console.WriteLine(&quot;-------主线程结束-------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        static async Task&lt;int&gt; GetLengthAsync()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;GetLengthAsync Start&quot;);  </span><br><span class="line">            string str = await GetStringAsync();</span><br><span class="line">            Console.WriteLine(&quot;GetLengthAsync End&quot;);</span><br><span class="line">            return str.Length;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        static Task&lt;string&gt; GetStringAsync()</span><br><span class="line">        &#123;</span><br><span class="line">            return Task&lt;string&gt;.Run(() =&gt; &#123; Thread.Sleep(2000); return &quot;finished&quot;; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>当调用GetLengthAsync方法时候，注意此处没有加await关键字，它会像正常的执行同步代码一样执行Console.WriteLine(“GetLengthAsync Start”)，直到遇到await关键字后， 程序首先做的是判断该任务是否执行完毕，通常是没有完毕，不管它有没有完毕，程序先把控制权返回给调用异步任务的<strong>调用者（caller）</strong>，因此调用者此时没有等待，会继续执行， 执行到下一行Console.WriteLine(“Task返回的值” + task.Result)，程序明确表示我要这个结果，此时调用者只好等待，会等待任务GetLengthAsync返回结果，返回结果后才能继续执行。 因此当一个方法去call一个含有await关键字的异步任务时候是不需要等待的，只有需要这个任务(task)的结果,使用task.resut，这个方法才会暂停等待异步任务返回结果（正常返回值或者exception）。</p><h3 id="问题二：是否开启了新的线程"><a href="#问题二：是否开启了新的线程" class="headerlink" title="问题二：是否开启了新的线程"></a>问题二：是否开启了新的线程</h3><p>要看异步任务中调用的方法是否会使用<strong>Task.Run(()=&gt;{}),Task.Factory.StartNew(()=&gt;{})</strong>以及NET内置带有Async结尾的异步方法，只有await这些方法时才会从 线程池中寻找空闲的线程去执行这些方法。</p><h3 id="问题三：任务一定是异步的吗"><a href="#问题三：任务一定是异步的吗" class="headerlink" title="问题三：任务一定是异步的吗"></a>问题三：任务一定是异步的吗</h3><p>不一定，看你如何调用，比如创建一个简单任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Task&lt;string&gt; CreateTask()&#123;</span><br><span class="line">   Task.Run(()=&gt;&#123;</span><br><span class="line">     return &quot;Hello hugo...&quot;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这就是个最普通的任务，如果你有一个方法使用await CreateTask()的话，那么这个方法将会变成需要使用<strong>async</strong>标记的异步方法，其返回值是Task<string>。如果使用 CreateTask.Result或者CreateTask.Wait()方法，这个方法依旧是普通同步方法，因为Result和Wait()都是本身就是阻塞方法。</string></p><h3 id="问题四：await究竟干了啥（从代码角度）"><a href="#问题四：await究竟干了啥（从代码角度）" class="headerlink" title="问题四：await究竟干了啥（从代码角度）"></a>问题四：await究竟干了啥（从代码角度）</h3><p>await关键字告诉编译器在async方法中插入一个可能唤醒、继续的操作点。</p><p>await smth时候，编译器生成相应代码，代码第一步先检查smth这个耗时操作是否完成，如果已经完成，则继续运行await标记点之后的代码；如果没有完成，编译器生成一个需要<strong>后续操作的委托</strong>，同时return到调用异步任务的方法中去，也就是所谓的将控制权返回给调用者（caller）。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program11</span></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>     &#123;</span><br><span class="line">         Console.WriteLine("----主线程启动----"); ::</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">"主线程执行线程:"</span> + Thread.CurrentThread.ManagedThreadId + <span class="string">" 是否后台:"</span> + Thread.CurrentThread.IsBackground);</span><br><span class="line"></span><br><span class="line">         Task&lt;<span class="keyword">int</span>&gt; task =  GetStringLengthAsync();</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">"----主线程继续执行----"</span>);</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">"Task返回值:"</span> + task.Result);</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">"主线程执行线程:"</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">"---主线程结束----"</span>);</span><br><span class="line"></span><br><span class="line">         Console.ReadKey();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="keyword">int</span>&gt; <span class="title">GetStringLengthAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>     &#123;</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">"GetStringLengthAsync方法开始执行..."</span>);</span><br><span class="line">         Console.WriteLine(<span class="string">"GetStringLengthAsync 执行线程:"</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">string</span> str = <span class="keyword">await</span> GetStringTask();</span><br><span class="line">         Console.WriteLine(<span class="string">"GetStringLengthAsync 执行线程:"</span> + Thread.CurrentThread.ManagedThreadId + <span class="string">"是否后台："</span> + Thread.CurrentThread.IsBackground);</span><br><span class="line">         <span class="keyword">return</span> str.Length;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">static</span> Task&lt;<span class="keyword">string</span>&gt; <span class="title">GetStringTask</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>     &#123;</span><br><span class="line">         <span class="keyword">var</span> client = <span class="keyword">new</span> HttpClient();</span><br><span class="line">         Task&lt;<span class="keyword">string</span>&gt; task = client.GetStringAsync(<span class="string">"http://blog.stephencleary.com/2012/02/async-and-await.html"</span>);</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">"GetStringTask 执行线程:"</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">         <span class="keyword">return</span> task;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这是执行结果，看看跟你想的一样不。 <a href="https://postimg.org/image/iim982ys7/" target="_blank" rel="noopener"><img src="https://s23.postimg.org/bs5rynbmj/QQ_20170124120621.jpg" alt="运行结果"></a></p><p>然后我们使用.NET Reflector反编译下程序，看看编译器如何处理await smth的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public class Program11</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    // Nested Types</span><br><span class="line">    [CompilerGenerated]</span><br><span class="line"> //这是一个带有状态机的类，状态机，是不是让你联想到可以检测状态，状态恢复之类的</span><br><span class="line">    private sealed class &lt;GetStringLengthAsync&gt;d__1 : IAsyncStateMachine</span><br><span class="line">    &#123;</span><br><span class="line">        // Fields</span><br><span class="line">        // 初始化相关字段</span><br><span class="line">        public int &lt;&gt;1__state;</span><br><span class="line">        private string &lt;&gt;s__2;</span><br><span class="line">        public AsyncTaskMethodBuilder&lt;int&gt; &lt;&gt;t__builder;</span><br><span class="line">        private TaskAwaiter&lt;string&gt; &lt;&gt;u__1;</span><br><span class="line">        private string &lt;str&gt;5__1;</span><br><span class="line"></span><br><span class="line">        // Methods</span><br><span class="line">        // 关键看这里</span><br><span class="line">        private void MoveNext()</span><br><span class="line">        &#123;</span><br><span class="line">            int length;</span><br><span class="line">            int num = this.&lt;&gt;1__state;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                //创建一个等待着，等待着专门用来等待异步任务，并检测任务是否完毕</span><br><span class="line">                TaskAwaiter&lt;string&gt; awaiter;</span><br><span class="line">                //一开始num不等于0，所以直接进入</span><br><span class="line">                if (num != 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;GetStringLengthAsync方法开始执行...&quot;);</span><br><span class="line">                    Console.WriteLine(&quot;GetStringLengthAsync 执行线程:&quot; + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">                    //为等待者着赋值，注意这里的代码是在线程池运行的</span><br><span class="line">                    awaiter = Program11.GetStringTask().GetAwaiter();</span><br><span class="line">                    //一开始时候是没有完成，所以进入该方法</span><br><span class="line">                    if (!awaiter.IsCompleted)</span><br><span class="line">                    &#123;   </span><br><span class="line">                       </span><br><span class="line">                        this.&lt;&gt;1__state = num = 0;</span><br><span class="line">                        this.&lt;&gt;u__1 = awaiter;</span><br><span class="line">                        </span><br><span class="line">                        Program11.&lt;GetStringLengthAsync&gt;d__1 stateMachine = this;</span><br><span class="line">                        //创建一个需要后续操作的委托，通过AwaitUnsafeOnCompleted实现，当操作完成时候，程序再次调用MoveNext()方法，这次就会直接进入程序的下半部分，从else进入                 </span><br><span class="line">                        this.&lt;&gt;t__builder.AwaitUnsafeOnCompleted&lt;TaskAwaiter&lt;string&gt;, Program11.&lt;GetStringLengthAsync&gt;d__1&gt;(ref awaiter, ref stateMachine);</span><br><span class="line">                        //很重要，返回控制权给调用者，所以不会阻塞调用者(caller)</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    awaiter = this.&lt;&gt;u__1;</span><br><span class="line">                    this.&lt;&gt;u__1 = new TaskAwaiter&lt;string&gt;();</span><br><span class="line">                    this.&lt;&gt;1__state = num = -1;</span><br><span class="line">                &#125;</span><br><span class="line">                //这块就是任务完成之后的后续操作</span><br><span class="line">                string result = awaiter.GetResult();</span><br><span class="line">                awaiter = new TaskAwaiter&lt;string&gt;();</span><br><span class="line">                this.&lt;&gt;s__2 = result;</span><br><span class="line">                this.&lt;str&gt;5__1 = this.&lt;&gt;s__2;</span><br><span class="line">                this.&lt;&gt;s__2 = null;</span><br><span class="line">                Console.WriteLine(string.Concat(new object[] &#123; &quot;GetStringLengthAsync 执行线程:&quot;, Thread.CurrentThread.ManagedThreadId, &quot;是否后台：&quot;, Thread.CurrentThread.IsBackground.ToString() &#125;));</span><br><span class="line">                length = this.&lt;str&gt;5__1.Length;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception exception)</span><br><span class="line">            &#123;</span><br><span class="line">                this.&lt;&gt;1__state = -2;</span><br><span class="line">                this.&lt;&gt;t__builder.SetException(exception);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            this.&lt;&gt;1__state = -2;</span><br><span class="line">            this.&lt;&gt;t__builder.SetResult(length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><ul><li><a href="https://msdn.microsoft.com/en-us/magazine/jj991977.aspx" target="_blank" rel="noopener">Best Practices in Asynchronous Programming</a>：深刻解释async await void和configure context</li><li><a href="https://msdn.microsoft.com/en-us/library/hh191443.aspx" target="_blank" rel="noopener">使用async/await异步编程-微软官方</a></li><li><a href="https://blogs.msdn.microsoft.com/pfxteam/2012/04/12/asyncawait-faq/" target="_blank" rel="noopener">async/await常见问题</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> .NET开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你了解BSON吗</title>
      <link href="/bson/"/>
      <url>/bson/</url>
      
        <content type="html"><![CDATA[<p>我们都使用过JSON，也听说过BSON（Binary Serialized Document Format）是一种基于二进制形式的存储格式，具有轻量性、高效性的特点，可是为什么它很高效呢，为什么MongoDB会选择使用这种事格式来存储数据呢，跟着本文一探究竟吧。</p><a id="more"></a><h4 id="BSON-格式"><a href="#BSON-格式" class="headerlink" title="BSON 格式"></a>BSON 格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Name&quot;:&quot;Hugo&quot;,</span><br><span class="line">  &quot;Age&quot;:25,</span><br><span class="line">  &quot;Address&quot;: [&quot;8 Rue Sevin&quot;,&quot;3 Rue Tronchet&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子就是一个最简单的BSON存储格式，外面的”{}”来告诉BSON解释其这是一个Document，我之所以说成Document是为了让你联想到MongoDB，因为MongoDB也是用Document存储数据的。在一个Document中包含着若干个element-元素，每个Element由3部分组成，<strong>名称</strong>，<strong>类型</strong>，<strong>值</strong>，上面例子中”Name”就是element的名称，”Hugo”就是这个element的值，BSON所支持的类型包括：</p><ul><li>String</li><li>Interger（Int32 和Int64）</li><li>double（64位）</li><li>date（UTC格式）</li><li>byte数组</li><li>boolean</li><li>null</li><li>BSON object</li><li>BSON array</li><li>JavaScript Code</li><li>正则表达式</li></ul><h4 id="高效性"><a href="#高效性" class="headerlink" title="高效性"></a>高效性</h4><p>跟JSON相比，BSON最初的设计方案就是为了提高数据检索的，特别对于一个很大的Document来说，BSON就有很高的检索速度，BSON在存储数据时候会记录长度前缀-length prefix和explicit array indice-明确的说明。</p><h4 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h4><p>BSON最新的1.1版本中，一共定义了6个类型来序列化数据存储到计算机中。<code>byte,int32,int64,uint64,double,decimal128</code>。比较常用的是前四种。在存储数据的时候使用的是little-endian-小端存储，即低位字节存放在较低的存储器地址,<a href="http://blog.magicyu.com/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" target="_blank" rel="noopener">了解更多</a>。</p><h4 id="存储规则"><a href="#存储规则" class="headerlink" title="存储规则"></a>存储规则</h4><p>根据BSON规则，一个Document被分解成三部分，<strong>Int32，e_list，”\x00”</strong>。</p><ul><li>Int32：记录该Document的总长度，使用Int32存储，占用了4个字节，这个总长度也包括了Int32本身的长度，安小端排序存储。</li><li>e_list：作为BSON规则中的一个中间内容，它包括两部分，<strong>element,e_list</strong>，注意这里要有递归思想，解释器肯定是依次解释element的，对于还没有进行解释的，BSON称之为e_list，这是一个<strong>中间形式</strong>，解释器的最终结果是把document中的element都解释出来。</li><li>“\x00”：这个16进制相当于一个结束符，表示该部分解释已经结束。</li></ul><h5 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h5><p>我使用ASP.NET Web API输出一个BSON数据，通过Fiddler可以看出其结果的Hexstring。</p><img src="/bson/bson1.jpg" title="BSON结果"><p>绿色部分是Http Response中的Header部分，黑色部分是Body部分。我们首先自己试着解析出结果，看能否与输出结果匹配。</p><p>对于<code>&quot;Name&quot;:&quot;Hugo&quot;</code>，首先根据BSON规则，</p><img src="/bson/bson.png" title="BSON规则"><p>element需要解析成 <strong>数据类型部分 e_name 值</strong>三部分，因为这个element是个string类型，因此数据类型部分被解释成”\x02”，e_name需要解释成cstring， 然后cstrig又被解释成(byte<em>) “\x00”，byte</em>代表一个或多个byte，查询ASCII码表，知道Name为4E 61 6D 65，加上\x00，完整的Name为4E 61 6D 65 00， 值等于string，string又被解释成int32 (byte*) “\x00”， 分别代表字符串的个数+1（+1是因为算上”\x00”结束符），每个字符对应的UTF8编码，结束符。值是Hugo， 被解析成05 00 00 00 48 75 67 6F 00，<strong>注意</strong>Int32总是按<strong>4个字节小端存储</strong>。 一个完整的Name对应的16进制字符串是<code>02 4E 61 6D 65 00 05 00 00 00 48 75 67 6F 00</code> 和 Fiddler给出的结果完全匹配。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>由于每个元素的长度都存储在元素的头部，因此可以根据这个长度直接进行seek到指定的点上就可以读到内容了，这就是为什么遍历速度快！额外的存储空间是BSON一个劣势势，比如对{“field”:2}，在JSON的存储上7只使用了一个字节，而如果用BSON，那就是至少4个字节（32位），因为BSON没有Int 16类型，哈哈。</p><p>JSON是一个很方便的数据交换格式，但是其类型比较有限。BSON在其基础上增加了“byte array”数据类型。这使得二进制的存储不再需要先base64转换后再存成JSON。大大减少了计算开销和数据大小。</p><p>对于BSON的设计，确实达到了这三点目标：<strong>更快的遍历速度、操作更简易、增加了额外的数据类型</strong></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><hr><ul><li><a href="http://bsonspec.org/" target="_blank" rel="noopener">BSON官方文档</a></li><li><a href="http://blog.nosqlfan.com/html/2914.html" target="_blank" rel="noopener">BSON特性探讨及基于其特性的MongoDB优化</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 理解计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Web API-路由篇</title>
      <link href="/webapi1/"/>
      <url>/webapi1/</url>
      
        <content type="html"><![CDATA[<p>由于项目的需要使用ASP.NET Web API进行开发，因此决定回顾下Web API，在ASP.NET Web API中，路由起到了定位controller、action，并将数据传入到action中，把客户端发来的请求<strong>映射</strong>到对应的action上的过程，它和ASP.NET MVC中的路由一个主要区别是MVC中的路由是基于URI的，而API中的路由是基于HTTP的，除此之外路由表、路由属性等知识都需要了解下。</p><a id="more"></a><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="Route-Table-路由表"><a href="#Route-Table-路由表" class="headerlink" title="Route Table-路由表"></a>Route Table-路由表</h4><p>在ASP.NET Web API中controller是一个处理http请求的类，在这个类中定义了一些方法,如果没有加<strong>NonAction</strong>标记的话都认为它是action。当API Framework收到请求后，会路由到对应action。在创建完API项目之后，VS会自动为我们创建一个默认路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">routes.MapHttpRoute(</span><br><span class="line">    name: &quot;API Default&quot;,</span><br><span class="line">    routeTemplate: &quot;api/&#123;controller&#125;/&#123;id&#125;&quot;,</span><br><span class="line">    defaults: new &#123; id = RouteParameter.Optional &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在这个默认路由模板中，controller和id是两个变量，分别对应controller的名字和可选参数。</p><p>&emsp;&emsp;&emsp;/api/contacts</p><p>&emsp;&emsp;&emsp;/api/contacts/1</p><p>&emsp;&emsp;&emsp;/api/products/gizmo1</p><p>像类似的请求URI都是匹配默认路由的。API Framework首先会检查请求URL是否匹配默认路由，如果匹配的话，会进入选择controller和action阶段。通过URI中的{controller}进入到对应的controller。 一个controller中的方法有那么多路由引擎是如何找到对应的action呢？它会根据你定义的action名称来找，如果你定义的action以Get开头，类似”GetBook” “GetProduct”这样的action时候，路由引擎会认为这是一个Get请求，因此路有引擎根据action名称中是否含有<strong>Get|Post|Put|Delete</strong>关键字来匹配URI和action的。如果URI中如果有id这个可选参数的话，会把该参数传入到action内。</p><h4 id="路由action"><a href="#路由action" class="headerlink" title="路由action"></a>路由action</h4><p>可以想象出一个路由如果有多个以Get开头的action话就不太容易定位了，那么该怎么办呢，有两个选择改变默认路由模板，添加action变量到模板中，或者使用Attribute Routing。默认路由只精确到了controller，我们需要在默认路由的模板中添加{action}部分。可以自己新定义一个路由模板，路由中包含3个参数位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">routes.MapHttpRoute(</span><br><span class="line">    name: &quot;ActionApi&quot;,</span><br><span class="line">    routeTemplate: &quot;api/&#123;controller&#125;/&#123;action&#125;/&#123;id&#125;&quot;,</span><br><span class="line">    defaults: new &#123; id = RouteParameter.Optional &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过使用<strong>ActionName</strong>来覆盖action本身的方法名，在下面例子中，两个方法都可以map到”api/products/thumbnail/id”，其中一个是Get 另一个是Post。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ProductsController : ApiController</span><br><span class="line">&#123;</span><br><span class="line">    [HttpGet]</span><br><span class="line">    [ActionName(&quot;Thumbnail&quot;)]</span><br><span class="line">    public HttpResponseMessage GetThumbnailImage(int id);</span><br><span class="line">    [HttpPost]</span><br><span class="line">    [ActionName(&quot;Thumbnail&quot;)]</span><br><span class="line">    public void AddThumbnailImage(int id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Attribute-Routing-特性路由"><a href="#Attribute-Routing-特性路由" class="headerlink" title="Attribute Routing-特性路由"></a>Attribute Routing-特性路由</h4><p>convetion-based routing基于公约的路由是Web API最初版本使用的路由规则，它最大的好处就是在一个文件中定义一个或者多个路由模板方案用来匹配URI，这个规则可以应用到项目中的所有controller， 但是这种定义规则不适用于某些场景，比如一个controller中含有多个子资源，或者有关联关系的资源，比如我们想得到某一个客户底下的所有订单：<code>/customers/1/orders</code>这样的路由， 为了写出符合Restful规范的路由，传统的convention-based路由就显得有些吃力了，我么需要在每一个action中进行个性化定义路由，因此Web API 2.0版本推出了Attribute Routing。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Route(&quot;customers/&#123;customerId&#125;/orders&quot;)]</span><br><span class="line">public IEnumerable&lt;Order&gt; GetOrdersByCustomer(int customerId) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h5 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h5><ul><li>在不改变action名称的情况下可以灵活修改</li><li>有关联资源时，可以创建更加符合Restful规范的路由</li><li>精细化控制</li></ul><h4 id="Route-Prefixes-路由前缀定义"><a href="#Route-Prefixes-路由前缀定义" class="headerlink" title="Route Prefixes-路由前缀定义"></a>Route Prefixes-路由前缀定义</h4><p>通过定义RoutePrefixes来为一个controller设置路由公用前缀。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[RoutePrefix(&quot;api/books&quot;)]</span><br><span class="line">public class BooksController : ApiController</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果在一个action中不想使用RoutePrefix，可以使用<strong>~</strong>进行覆盖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[RoutePrefix(&quot;api/books&quot;)]</span><br><span class="line">public class BooksController : ApiController</span><br><span class="line">&#123;</span><br><span class="line">    // GET /api/authors/1/books</span><br><span class="line">    [Route(&quot;~/api/authors/&#123;authorId:int&#125;/books&quot;)]</span><br><span class="line">    public IEnumerable&lt;Book&gt; GetByAuthor(int authorId) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Route-Constraints-路由约束"><a href="#Route-Constraints-路由约束" class="headerlink" title="Route Constraints-路由约束"></a>Route Constraints-路由约束</h4><p>路有约束用来指定路由中的参数名称和类型，句式为<code>{parameter:constraint}</code>,比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Route(&quot;users/&#123;id:int&#125;&quot;]</span><br><span class="line">public User GetUserById(int id) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p></p><p>也可以进行多重约束，每个约束通过”/“进行分割。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Route(&quot;users/&#123;id:int:min(1)&#125;&quot;)]</span><br><span class="line">public User GetUserById(int id) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h4 id="自定义路由约束"><a href="#自定义路由约束" class="headerlink" title="自定义路由约束"></a>自定义路由约束</h4><p><a href="https://www.asp.net/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2" target="_blank" rel="noopener">参考这里</a></p><h4 id="Optional-default-paramters-可选、默认参数"><a href="#Optional-default-paramters-可选、默认参数" class="headerlink" title="Optional,default paramters-可选、默认参数"></a>Optional,default paramters-可选、默认参数</h4><ul><li><p>可选参数并具有默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class BooksController : ApiController</span><br><span class="line">&#123;</span><br><span class="line">    [Route(&quot;api/books/locale/&#123;lcid:int?&#125;&quot;)]</span><br><span class="line">    public IEnumerable&lt;Book&gt; GetBooksByLocale(int lcid = 1033) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>默认参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class BooksController : ApiController</span><br><span class="line">&#123;</span><br><span class="line">    [Route(&quot;api/books/locale/&#123;lcid:int=1033&#125;&quot;)]</span><br><span class="line">    public IEnumerable&lt;Book&gt; GetBooksByLocale(int lcid) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="定义路由名称"><a href="#定义路由名称" class="headerlink" title="定义路由名称"></a>定义路由名称</h4><p>通过使用<strong>Name</strong>设置action的路由名称，并且可以生成这个action的URI通过定义的<strong>Name</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class BooksController : ApiController</span><br><span class="line">&#123;</span><br><span class="line">    [Route(&quot;api/books/&#123;id&#125;&quot;, Name=&quot;GetBookById&quot;)]</span><br><span class="line">    public BookDto GetBook(int id) </span><br><span class="line">    &#123;</span><br><span class="line">        // Implementation not shown...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [Route(&quot;api/books&quot;)]</span><br><span class="line">    public HttpResponseMessage Post(Book book)</span><br><span class="line">    &#123;</span><br><span class="line">        var response = Request.CreateResponse(HttpStatusCode.Created);</span><br><span class="line"></span><br><span class="line">        //可以传入参数到这个action中</span><br><span class="line">        string uri = Url.Link(&quot;GetBookById&quot;, new &#123; id = book.BookId &#125;);</span><br><span class="line">        response.Headers.Location = new Uri(uri);</span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><hr><ul><li><a href="https://www.asp.net/web-api/overview/web-api-routing-and-actions" target="_blank" rel="noopener">官方路由讲解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> .NET开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Web API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简析.NET Core</title>
      <link href="/Core/"/>
      <url>/Core/</url>
      
        <content type="html"><![CDATA[<p>.NET Core已经诞生了一年多了，作为一个从.NET做起的的开发人员，肯定希望.NET可以逐渐壮大，在Mac、Linux平台上都可以大显神威，微软每走一步都会都广大的开人人员有很不少影响，所以有必要了解.NET Core体系结构。</p><a id="more"></a><h3 id="为什么我们需要-NET-Core"><a href="#为什么我们需要-NET-Core" class="headerlink" title="为什么我们需要.NET Core"></a>为什么我们需要.NET Core</h3><h4 id="跨平台的需要"><a href="#跨平台的需要" class="headerlink" title="跨平台的需要"></a>跨平台的需要</h4><p>如果你的目标是创建一个应用可以运行到多个平台(Windows,Linux,MacOS)，最好的选择是使用.Net Core作为运行时(CoreCLR)和跨平台的类库。另外一个选择就是使用<a href="https://github.com/mono" target="_blank" rel="noopener">Mono Project</a>。</p><p>两个选择都是开源的，但是微软明确，官方的表示将会投入大量兵力去开发.NET Core。</p><p>当使用.NET Core跨平台时，最好的开发体验还是在Windows下使用Visual Studio进行开发，因为它支持了许多提高生产力的功能，比如项目管理（TFS）、本地调试、远程调试、智能编辑器、测试等等。但这并不表示在其他平台开发.NET Core就会使生产力降低，本人在Mac上使用VSCode开发感觉很有快感，体积小并且快速是VSCode的一个亮点，再也不会像过去在Windows上打开项目会很久的情况出现，同时VSCode也支持debug，总之对于常见功能都可以在VSCode上找到。对于其他第三方编辑器Sublime，Emacs，Atom来说，只要装上Omnisharp插件，开发.NET Core应用将会变得更加方便。</p><h4 id="微服务-Microservices"><a href="#微服务-Microservices" class="headerlink" title="微服务-Microservices"></a>微服务-Microservices</h4><p>试想下当你开发一个Microservice的应用时候，最大的好处就是微服务中的每一部分可以使用不同的技术、framework、编程语言进行开发。如果你想创建一个高效、覆盖面广的微服务，你应该试一试.NET Core。</p><h4 id="高可用性，高扩展性"><a href="#高可用性，高扩展性" class="headerlink" title="高可用性，高扩展性"></a>高可用性，高扩展性</h4><p>当你的平台需要良好的可用性、高扩展性的时候，.NETCore 和ASP.NET Core有着不俗的表现，</p><h4 id="基于命令行的开发方式"><a href="#基于命令行的开发方式" class="headerlink" title="基于命令行的开发方式"></a>基于命令行的开发方式</h4><p>如果你曾经或者现在是个使用轻量级的文本编辑器并擅长使用命令进行开发的技术人员的话，那么.NET Core可以让你有同样的感觉，.NET Core当初就是被设计成CLI的。在VS Code工具中，常用的命令需要在命令行中进行完成，而不会在像Visual Studio那样提供很庞大甚至臃肿的操作界面了，轻便简介是微软为了更好的拥抱开源所作出对编译器的改变。</p><h3 id="NET-Framework-vs-NET-Core"><a href="#NET-Framework-vs-NET-Core" class="headerlink" title=".NET Framework vs .NET Core"></a>.NET Framework vs .NET Core</h3><h4 id="NET-Framwork"><a href="#NET-Framwork" class="headerlink" title=".NET Framwork"></a>.NET Framwork</h4><p>对于.NET Framework来说，从微软推出的第一个Framework到现在，数年间每个Framework都有类似的体系但又有自己的特有功能，以用于在不同的设备和平台上运行。</p><p><img src="http://qiniu.xdpie.com/c6c5a11235efd0aac9620cdbcaae2633.png?imageView2/2/w/700&amp;_=5603928" alt=".NET Framework"> -</p><h4 id="NET-Core"><a href="#NET-Core" class="headerlink" title=".NET Core"></a>.NET Core</h4><p>为了改进上述问题，微软开发出来了.NET Core，是一个开源的模块化的Framework，不管是开发web或移动设备都在同一个Framework（.NET Core）下运行，而且 .NET Core也可在不同的操作系统上运行，包括Windows、linux、MacOS，实现了跨平台跨设备。</p><p><img src="http://qiniu.xdpie.com/539007367e8973b9b97b49b2f2d3450e.png?imageView2/2/w/700&amp;_=5613373" alt=".NET Core"></p><p>上图描述了 .NET Core的系统构成，最上层是应用层，是开发基于UI应用的框架集，包括了ASP.NET Core(用于创建web app)，和 UWP(用于创建Windows10 app)。</p><p>中间层是公共库(CoreFX),实现了.NET Standard Library ,囊括了常用系统级操作例如（文件、网络等）。</p><p>在CoreFx下是运行时环境，.NET Core 包含了两种运行时(CoreCLR、CoreRT),CoreCLR是一种基于即时编译程序(Just in time compiler,JIT)的运行时,它使用了跨平台开源的编译器RyuJIT,而CoreRT是使用提前编译器(Ahead of time compiler,AOT)的运行时,它既可以使用RyuJIT来实现AOT编译也可以使用其他的AOT编译器。由于AOT提前编译IL成了机器码，在移动设备上也具有更好的启动速度和节能性。</p><h4 id="与-NET-Framwork比较"><a href="#与-NET-Framwork比较" class="headerlink" title="与.NET Framwork比较"></a>与<strong>.NET Framwork</strong>比较</h4><ul><li><p>应用模型 – .NET Core 不支持所有 .NET Framework 应用模型，某种程序上是因为其中许多模型都是基于 Windows 技术，如 WPF（基于 DirectX 生成）。 但 .NET Core 和 .NET Framework 两者都支持控制台和 ASP.NET Core 应用模型。</p></li><li><p>API – .NET Core 包含很多与 .NET Framework 相同，但数量较少的 API，并且具有不同的组成要素（程序集名称不同；关键用例中的类型形状不同）。 目前，这些差异通常都需要更改，以将源移植到 .NET Core。 .NET Core 实现 .NET 标准库 API，该 API 将随着时间推移而增长，以便包含更多 .NET Framework BCL API。</p></li><li><p>子系统 – .NET Core 实现 .NET Framework 中子系统的子级，目的是实现更简单的实现和编程模型。 例如，不支持代码访问安全性 (CAS)，但支持反射。</p></li><li><p>平台 – .NET Framework 支持 Windows 和 Windows Server，而 NET Core 还支持 macOS 和 Linux。</p></li><li><p>开放源 – .NET Core 属于开放源，而 .NET Framework 的只读子集属于开放源。</p></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><hr><ul><li><a href="http://www.cnblogs.com/vipyoumay/p/5603928.html" target="_blank" rel="noopener">简析.NET Core 以及与 .NET Framework的关系</a></li><li><a href="http://www.cnblogs.com/vipyoumay/p/5613373.html" target="_blank" rel="noopener">简析.NET Core 体系</a></li><li><a href="https://docs.microsoft.com/zh-cn/dotnet/articles/core/" target="_blank" rel="noopener">.NET Core指南</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> .NET开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NET Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符编码</title>
      <link href="/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
      <url>/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>字符编码可以说是一个被人忽视却很重要的知识，因为我们只是大概知道个所以然，但是又不能准确了解字符编码的原理，举个例子，为什么会出现乱码，emoji又是怎么回事呢，包括我在内也只是大体上了解，所以今天打算一探究竟，做个总结。</p><a id="more"></a><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>字符编码中有两个东西，一是<strong>字符</strong>，二是<strong>编码</strong>，一个中文汉字代表一个字符，一个英文字母也代表一个字符。当许多字符堆在一块的时候就形成了<strong>字符集</strong>，比如英语、法语、汉语等。<strong>字符集</strong>由三个重要部分组成：<strong>字库表</strong>、<strong>编码字符集</strong>、<strong>字符编码</strong>。</p><p><strong>字库表</strong>里面记录了对应语言的所能表述的所有字符，<strong>编码字符集</strong>是表示字符在字库表里的位置的概念，比如苹果在汉语字库表的第1234页，在法语字库表的第3000页，请把苹果想象成一个字符，这里面的1234和3000就是一个<strong>编码值</strong>（code point），而<strong>字符编码</strong>是表述字符集转换成实际存储数据010101010的过程。 我们肯定听说过ASCII，UTF8，GB2312，Unicode编码，为啥会有这么多编码呢？？？</p><h3 id="ASCII编码"><a href="#ASCII编码" class="headerlink" title="ASCII编码"></a>ASCII编码</h3><p>因为计算机是美国人发明的，美国人只需要用26个字符和常见的标点符号就可以把所有的意思表述完毕了，因此发明了ASCII编码（美国信息交换标准代码）。</p><p><img src="http://www.asciitable.com/index/asciifull.gif" alt="ASCII"></p><p>可以看出它只包含了128个字符，老美够抠的，用7位二进制数表示，由于计算机1个字节是由8个二进制位组成的，因此ASCII编码中的字符只需用一个字节就可以表示完毕，单字节存储到计算机中，00000000-01111111，0x00-0x7F。</p><h3 id="非ASCII编码"><a href="#非ASCII编码" class="headerlink" title="非ASCII编码"></a>非ASCII编码</h3><p>可以想象，我们中国人肯定是不够用的，光是汉字就有5-6万个，经常使用的汉字至少也得5000个，因此我们发明了GB2312（中华人民共和国国家标准简体中文字符集），GB2312标准共收录6763个汉字，其中一级汉字3755个，二级汉字3008个；同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个字符。与此同时像港台的BIG5，GB2312的扩充版本GBK都是采用说双字节存储。双字节是变长的，比如有些简单字符用单字节存储，有些复杂字符用双字节存储，同时设计初衷希望兼容ASCII编码，带来的缺点是会存在空字位，造成资源浪费。</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>注意这里我没有说它是编码，因为Unicode设计初衷是为了制定一个统一规则定义字符，它是一个很庞大的字符集，从它的字面就可以看出，<strong>统一的，宇宙的</strong>。 目前最新的版本为2016年6月21日公布的9.0.0[2]，已经收入超过十万个字符，只要不是自己意淫出来的，在Unicode里都可以找到对应的字符，以及其所属code point（编码值）。 Unicode编号从0000到10FFFF（17个Plane），每个Plane包括256*256个字符，第一个Pane称为基本多文种平面（Basic Multiple Plane）简称BMP，其他的平面称为辅助平面（Supplementary Plane）。 Unicode规定每个符号用3个或者4个字节存储，可以想象无论编号低或高都用4字节存储，这会造成很大的存储浪费，因此并没有成为一个标准的字符编码，但是为日后的UTF8做了充足的准备。</p><h3 id="UTF8编码"><a href="#UTF8编码" class="headerlink" title="UTF8编码"></a>UTF8编码</h3><p>UTF8编码是Unicode的一种实现方式，每个字符的长度是变长的，可以提高存储的利用率。UTF8的编码规则如下：</p><ul><li>对于单字节的字符，字节的第一个字位是0，后面的7位是这个字符对应的Unicode码。因此对于英文字符来说，其UTF8编码和ASCII编码是一样的。</li><li>对于n字节符号，第一个字节的前n位是1，第n+1位是0，后面字节的前两位是10，剩下的字位全部为这个符号的Unicode码。</li></ul><table border="1" cellpadding="1" cellspacing="0"><thead><tr><th>Unicode符号编码范围</th><th>UTF8编码方式</th></tr></thead><tbody><tr><td>0000 0000-0000 007F</td><td>0xxxxxxx</td></tr><tr><td>0000 0080-0000 07FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>0000 0800-0000 FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>0001 0000-0010 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p>因此如果字节的第一位是0的话就代表这个字节就是一个字符，很可能是一个简单的英语字符。如果第一位是1的话，则连续有多少个1，就代表该字符有多少个字节。</p><h3 id="编码出现的问题"><a href="#编码出现的问题" class="headerlink" title="编码出现的问题"></a>编码出现的问题</h3><h4 id="乱码的出现"><a href="#乱码的出现" class="headerlink" title="乱码的出现"></a>乱码的出现</h4><p>是由于内容在存储到硬盘中和从硬盘中读取出来所使用的字符集不一致或者不兼容导致的。由于字符集不一样，那么每一个字符对应在不同的字符集位置不一样，因此会出现乱码。总结为存、取方式不一样。</p><h4 id="大端小端字节序问题"><a href="#大端小端字节序问题" class="headerlink" title="大端小端字节序问题"></a>大端小端字节序问题</h4><p>有一次在做项目时候，需要把数据库中的timestamp类型的数据取出来并转换为对应的Int64，C#程序中获取到的timestamp类型变成了byte[]类型，在转换成Int64之前需要将byte[]颠倒顺序，然后再调用<code>BitConvert.ToInt64()</code>方法。所以我好奇为什么需要将字节数组颠倒顺序，原来这和<strong>大端小端存储顺序</strong>有关。 Unicode对于一个字符采用多字节编码，存储数据到计算机内存中会有字节序问题。</p><ul><li>大端存储（Big Endian）: 内存中的低地址存储高字节位，高地址存储低字节位，符合人的主观想法逻辑。</li><li>小端存储（Little Endian）: 内存中的低地址存储低字节位，高地址存储高字节位，跟人的主观意识相反。</li></ul><blockquote><p>注意：对于大小端存储是指对于一个整数或者一个字符（包括数字、字母、汉字）对应的字节数组的存储顺序，不要想象成整个文本串的顺序，是整个文本串中的每一个字符的对应的码元的存储顺序。</p></blockquote><p>比如一个Int类型整数123456789，十六进制表达方式为：07-5B-CD-15。如果小端存储，在内存储中排序为：0x15 0xCD 0x5B 0x07 (低位在前)，大端存储，在内存中排序为：0x07 0x5B 0xCD 0x15 (高位在前)，高位对应byte[]中的第0个字节。</p><p>为啥会有不同的排序呢？因为这和计算机的CPU有关系，对于Intel系列-Windows/Linux X86/X64的CPU采用Little Endian方式存储，而对于IBM 370和摩托罗拉微处理器都是用Big Endian方式存储，JAVA编译的程序使用Big Endian。 对于小段储存，一个好处就是可以直接添加到内存的尾部，无需经过顺序颠倒，因此相比大端存储更加高效。</p><p>C#中<code>Encoding.Default.GetBytes()</code>可以直接得到字符串的字节数组，而且其字节数组就是一个大端排序。而用<code>BitConvert.GetBytes()</code>却得到一个整数的小段排序字节数组，这是为什么呢？ 因为对于使用UTF8编码的字符串，都是使用单个字节表示数字的，每个字节都有意义，当读取字节时候一定会从表示长度的那个字节开始读，无论正着存还是倒着存，队头队尾是确定的。 而使用对于数字来说，可能使用1个字节，2个字节或者多个字节存储，因此会有字节序问题，需要区分大小端，否则正着读是一个结果，倒着读又是一个结果。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><hr><ul><li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码笔记：ASCII，Unicode和UTF-8</a></li><li><a href="http://cenalulu.github.io/linux/character-encoding/" target="_blank" rel="noopener">十分钟搞清字符集和字符编码</a></li><li><a href="http://searchnetworking.techtarget.com/definition/big-endian-and-little-endian" target="_blank" rel="noopener">big-endian and little-endian</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 理解计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>https初探</title>
      <link href="/https%E5%88%9D%E6%8E%A2/"/>
      <url>/https%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p>HTTPS作为Web开发中必不可缺的一个重要知识点，我今天打算总结一下。</p><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS可以说是HTTP的一个强化版本，加强的部分主要是对于传输信息的加密，保证信息在传输的过程中无法被篡改，从而保证了信息的安全性。</p><a id="more"></a><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><h2 id="SSL-TLS由来"><a href="#SSL-TLS由来" class="headerlink" title="SSL/TLS由来"></a>SSL/TLS由来</h2><p>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p><ol><li>窃听风险（eavesdropping）：第三方可以获知通信内容。</li><li>篡改风险（tampering）：第三方可以修改通信内容。</li><li>冒充风险（pretending）：第三方可以冒充他人身份参与通信。</li></ol><p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p><ol><li>所有信息都是加密传播，第三方无法窃听。</li><li>具有校验机制，一旦被篡改，通信双方会立刻发现。</li><li>配备身份证书，防止身份被冒充。</li></ol><h2 id="SSL介绍"><a href="#SSL介绍" class="headerlink" title="SSL介绍"></a>SSL介绍</h2><p>SSL（Secure Sockets Layer，安全套接层），及其继任者 TLS（Transport Layer Security，传输层安全）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。</p><h2 id="SSL-TSL-基本过程："><a href="#SSL-TSL-基本过程：" class="headerlink" title="SSL/TSL 基本过程："></a>SSL/TSL 基本过程：</h2><ol><li>客户端向服务器端索要并验证公钥。</li><li>双方协商生成”对话密钥”。</li><li>双方采用”对话密钥”进行加密通信。</li></ol><p>上面过程的前两步，又称为”握手阶段”（handshake）。 由于证书中使用公约加密信息的计算量太大，因此客户端和服务器端协商生成一个对话秘钥，使用对话秘钥对以后传输的信息进行加密，减少了使用证书公钥耗用的时间，但是协商秘钥期间，会使用证书的公钥进行加密传输。</p><h2 id="实战说明：测试与pro-ihealthlabs-com进行连接-使用WireShark进行抓包分析"><a href="#实战说明：测试与pro-ihealthlabs-com进行连接-使用WireShark进行抓包分析" class="headerlink" title="实战说明：测试与pro.ihealthlabs.com进行连接 使用WireShark进行抓包分析"></a>实战说明：测试与pro.ihealthlabs.com进行连接 使用<strong>WireShark</strong>进行抓包分析</h2><h3 id="第一步：TCP三次握手"><a href="#第一步：TCP三次握手" class="headerlink" title="第一步：TCP三次握手"></a>第一步：TCP三次握手</h3><p>位码即tcp标志位，有6种标示：SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)。<br>tcp包重要信息：Sequence number(顺序号码) Acknowledge number(确认号码)。</p><p><strong>第一次握手</strong>:客户端192.168.1.31 发送位码syn包，并随机产生一个seq number=0(由于wireshark为了便于观察，初始化这个随机值为0,后面的seq和ack都在此基础上累加) <strong>第二次握手</strong>:pro主机54.76.150.159 收到syn包之后，必须确认客户端的syn包，发送ack包，因此添加位码ack number=1(上一步的seq number+1) ,ack=1 并随机一个seq number=0回复给客户端 <strong>第三次握手</strong>:客户端发送确认包 ack number=1 (上一步的seq number+1) 和ack=1发送给服务器，完成三次握手。 客户端与服务器开始进入https重要环节，协商秘钥。</p><h3 id="第二步：协商秘钥"><a href="#第二步：协商秘钥" class="headerlink" title="第二步：协商秘钥"></a>第二步：协商秘钥</h3><img src="/https初探/1.png" title="HTTPS handshake"><ul><li>客户端发送请求client hello</li></ul><p>在这一步中，客户端重要向服务器提供以下信息: 支持的协议版本，如图TLSv1.2版, 客户端生成的随机数(第一次）支持的加密算法,比如RSA公钥加密，支持的压缩方法。</p><img src="/https初探/2.png" title="Client hello"><p>需要注意的是，原本客户端发送的信息中不包括服务器的域名，也就是说服务器只包含一个网站，服务器用一个证书。但是对于虚拟主机用户来说这样很不方便， 因此2006年TLS协议加了一个Server name的扩展。</p><ul><li>服务器回应Server hello</li></ul><p>（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。 （2） 一个服务器生成的随机数(第二次)，稍后用于生成”会话密钥”(session secret)。 （3） 确认使用的加密方法，比如RSA公钥加密。 （4） 服务器证书。</p><img src="/https初探/3.png" title="Server hello"><ul><li><p>客户端再次回应</p><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。 （1） 一个随机数(第三次), 该随机数用上一步确定的加密算法（RSA或者Diffie-Hellman得到），又称”pre-master key”该随机数用服务器公钥加密，防止被窃听。 （2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。 （3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p><blockquote><p>不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。 对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器（Master Secret）最终导出一个对称密钥。 pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”</p></blockquote></li></ul><img src="/https初探/4.png" title="Client response"><ul><li>服务器最后回应</li></ul><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。 （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。 （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p><img src="/https初探/5.png" title="Server response"><h3 id="第三步：双方采用对话秘钥进行加密通信"><a href="#第三步：双方采用对话秘钥进行加密通信" class="headerlink" title="第三步：双方采用对话秘钥进行加密通信"></a>第三步：双方采用对话秘钥进行加密通信</h3><img src="/https初探/6.png" title="Application data"><h2 id="Secret-Key-生成过程流程图"><a href="#Secret-Key-生成过程流程图" class="headerlink" title="Secret Key 生成过程流程图:"></a>Secret Key 生成过程流程图:</h2><img src="/https初探/7.png" title="Secret key"><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><hr><ul><li><a href="http://www.haomou.net/2014/08/30/2014" target="_blank" rel="noopener">HTTPS详解SSL/TLS | 皓眸大前端</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
